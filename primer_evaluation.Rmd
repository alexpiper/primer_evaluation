---
title: "Metabarcoding primer evaluation"
subtitle: "Primer evaluation"
author: "Alexander Piper"
date: "`r Sys.Date()`"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
# Knitr global setup - change eval to true to run code
library(knitr)
knitr::opts_chunk$set(echo = TRUE, eval=FALSE, message=FALSE,error=FALSE, fig.show = "hold", fig.keep = "all")
opts_chunk$set(dev = 'png')
```


## Load packages
```{r load packages}
#Set required packages
.cran_packages <- c("usethis",
                    "tidyverse",
                    "tidymodels",
                    "chngpt",
                    "spider", 
                    "insect",
                    "ape",
                    "RColorBrewer",
                    "seqinr",
                    "patchwork",
                    "ShortRead",
                    "foreach",
                    "doParallel",
                    "TmCalculator",
                    "castor",
                    "furrr",
                    "UpSetR",
                    "DescTools")

.bioc_packages <- c("DECIPHER",
                    "ggtree",
                    "Biostrings")

.inst <- .cran_packages %in% installed.packages()
if(any(!.inst)) {
   install.packages(.cran_packages[!.inst])
}
.inst <- .bioc_packages %in% installed.packages()
if(any(!.inst)) {
  if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")
  BiocManager::install(.bioc_packages[!.inst], ask = F)
}

#Load all packages
sapply(c(.cran_packages,.bioc_packages), require, character.only = TRUE)

# Github packages
devtools::install_github("alexpiper/taxreturn")
library(taxreturn)
library(PrimerMiner)

# SOurce internal functions
source("R/helper_functions.R")
source("R/themes.R")
```


# Fig 1 - Database summary

```{r sequence tracker}
# Create read origins 
origin <- bind_rows(
  #Genbank Insecta
  fasta.index(list.files("reference/insecta/genbank", pattern = ".fa", full.names = TRUE)) %>%
  mutate(origin = "GenBank") %>% #genbank_insecta
  select(origin, desc),
  #BOLD Insecta
  fasta.index(list.files("reference/insecta/bold", pattern = ".fa", full.names = TRUE)) %>%
  mutate(origin = "BOLD") %>% #bold_insecta
  select(origin, desc),
  #Genbank Arachnida
  fasta.index(list.files("reference/arachnida/genbank", pattern = ".fa", full.names = TRUE)) %>%
  mutate(origin = "GenBank") %>% #genbank_arachnida
  select(origin, desc),
  #BOLD Arachnida
  fasta.index(list.files("reference/arachnida/bold", pattern = ".fa", full.names = TRUE)) %>%
  mutate(origin = "BOLD") %>% #bold_arachnida
  select(origin, desc),
) %>%
    mutate(seqid = desc %>%
    str_remove(pattern="(\\|)(.*?)(?=$)") %>%
    str_replace_all(" ", "_") ) %>%
  distinct() %>%
  mutate(Duplicated = case_when(
    duplicated(seqid) & str_detect(origin, "bold") ~ TRUE,
    TRUE ~ FALSE
    )) %>%
  filter(!Duplicated) %>%   
  filter(!duplicated(seqid)) %>%
  select(-Duplicated, -desc)

## summarise number of sequences at each stage and their origins
tracker <- bind_rows(
                  taxreturn::summarise_fasta("reference/01_mergedseqs.fa.gz",
                                             label="01_merged",
                                             origin=origin),
                  taxreturn::summarise_fasta("reference/02_uniqSeqs.fa.gz",
                                             label="02_unique",
                                             origin=origin),
                  taxreturn::summarise_fasta("reference/03_resolved.fa.gz",
                                             label="03_resolved",
                                             origin=origin),
                  taxreturn::summarise_fasta("reference/04_name_filtered.fa.gz",
                                             label="04_name_filt",
                                             origin=origin),
                  taxreturn::summarise_fasta("reference/05_filtered.fa.gz",
                                             label="05_phmm_filt",
                                             origin=origin),
                  taxreturn::summarise_fasta("reference/06_codon_filtered.fa.gz",
                                             label="06_codon_filt",
                                             origin=origin),
                  taxreturn::summarise_fasta("reference/07_purged.fa.gz",
                                             label="07_mixed_clusters",
                                             origin=origin),
                  taxreturn::summarise_fasta("reference/08_contam_removed.fa.gz",
                                             label="08_contam_removed",
                                             origin=origin), 
                  taxreturn::summarise_fasta("reference/09_lengthfilt.fa.gz",
                                             label="09_lengthfilt",
                                             origin=origin), 
                  taxreturn::summarise_fasta("reference/10_pruned.fa.gz", 
                                             label="10_pruned",
                                             origin=origin)

) %>%
  pivot_longer(cols=starts_with("n"),
               names_to = "Type",
               values_to = "value"
               )
write_csv(tracker, "reference/sequence_tracker.csv")

tracker <- read_csv("reference/sequence_tracker.csv")%>%
  filter(!origin %in% c("genbank_arachnida/genbank_insecta", "bold_arachnida/bold_insecta/genbank_arachnida/genbank_insecta")) 
tracker %>% 
  group_by(Type, label) %>%
  summarise(value = sum(value))

gg.cleaning <- tracker %>%
  mutate(Type = Type %>% 
           str_replace("nseqs", "# Sequences") %>%
            str_replace("nspecies", "# Species")) %>%
  ggplot(aes(x=label, y=value, group=origin, fill=origin)) +
  geom_col(alpha=0.8) +
  facet_wrap(~Type, nrow=2, ncol=1, scales = "free_y") +
  scale_fill_brewer(palette="Paired") +
  xlab("Filter stage") +
  ylab("# Sequences") +
  scale_y_continuous(labels = scales::comma) +
  base_theme + 
  theme(legend.position="top",
        panel.grid = element_blank()) +
  labs(x = "Filter stage",
       y = NULL,
       fill = "Sequence Origin")

gg.cleaning

#Save figure 1
pdf(file="fig/Fig1_database_summary.pdf", width = 11, height = 8 , paper="a4r")
  plot(gg.cleaning)
try(dev.off(), silent=TRUE)
  

# Pre and post pruning
pruning_summary <- Biostrings::fasta.index("reference/database_builder/09_lengthfilt.fa.gz") %>%
  bind_rows(Biostrings::fasta.index("reference/database_builder/10_pruned.fa.gz"))%>%
  mutate(species = desc %>% str_remove("^.*;")) %>%
  mutate(stage = case_when(
    str_detect(filepath, "lengthfilt") ~ "Unpruned",
    str_detect(filepath, "pruned") ~ "Pruned"
  )) %>%
  dplyr::select(species, stage) %>%
  group_by(species, stage) %>%
  summarise(n = n()) %>%
  ungroup()

gg.spp_hist <- pruning_summary %>%
  filter(stage=="Unpruned") %>%
  ggplot(aes(x = n)) +
  geom_histogram(binwidth = 0.5, fill="#a6cee3", colour="black")+
  scale_x_continuous(trans = "pseudo_log", breaks = c(seq(1,5,1),10, 20, 30, 50, 100, 1000, 10000, 40000), minor_breaks = NULL, labels = scales::label_number_si()) +
  scale_y_continuous(labels = scales::label_number_si(),expand=c(0.1,0))+
  geom_vline(xintercept = 5, lty=2)+
  base_theme+
  scale_fill_brewer(palette = "Paired") + 
  labs(x = "Sequences per species", y = "Number of Species") +
  theme(panel.grid = element_blank(),
        axis.text.x = element_text(angle=0))

gg.spp_box <- pruning_summary %>%
  filter(stage=="Unpruned") %>%
  ggplot(aes(x = stage, y=n)) +
  geom_boxplot(fill="#a6cee3", colour="black", alpha = 0.5) + 
  theme_void()+
  scale_y_continuous(trans = "pseudo_log", breaks = c(seq(1,5,1),10, 20, 30, 50, 100, 1000, 10000, 40000), minor_breaks = NULL, labels = scales::label_number_si()) +
  scale_fill_brewer(palette = "Paired") + 
  coord_flip() +
  theme(legend.position = "none")

gg.pruning <- gg.spp_hist + inset_element(gg.spp_box,   left = 0, bottom = 0, right = 1,  top = 0.09)

gg.pruning

#Supplementary pruning figure
pdf(file="fig/supplementary/seqs_per_spp.pdf", width = 8, height = 6 , paper="a4r")
  plot(gg.pruning)
try(dev.off(), silent=TRUE)

# Summary of unique taxa
seqs <- insect::readFASTA("reference/merged_final.fa.gz")

# Summarise unique ranks
names(seqs) %>%
  str_split_fixed(";", n=Inf) %>%
  as.data.frame() %>%
  magrittr::set_colnames(c("total", "kingdom", "phylum", "class", "order", "family", "genus", "species")) %>%
  dplyr::summarise_at(c("total", "kingdom", "phylum", "class", "order", "family", "genus", "species"), n_distinct) 
```

# Primer statistics

```{r primer binding and constraints}
#alignment was then manually curated in geneious primer
model <- readRDS("reference/folmer_fullength_model.rds")

# Be worth validating how the score is calculated?
primers <- read_csv("primer_evaluation/primer_candidates.csv") %>%
  select(name, strand, seq, citation, issues) %>%
  left_join(.$seq %>% purrr::map(get_binding_position, model, tryrc = TRUE, minscore=8) %>%
              bind_rows() %>%
              dplyr::rename(seq = primer), by="seq")%>%
  distinct()

primers <- primers %>%
  left_join(.$seq %>%
  purrr::map_df(get_primer_statistics, metrics="all", disambiguate=TRUE))  %>%
  select(-score, -issues) %>%
  select(-starts_with("poly")) %>%
  left_join(.$seq %>%
  purrr::map_df(get_primer_statistics, metrics="homopolymer", disambiguate=FALSE))

write_csv(primers, "primer_evaluation/primer_candidates.csv")

#Number of unique forward and reverse
primers %>% 
  dplyr::select(seq, strand) %>%
  distinct() %>%
  pull(strand) %>%
  table()
```

## Primer Presence in seqs

```{r check pres}
primerHits <- function(primer, fn, max.mismatch=0, with.indels=FALSE) {
      if(stringr::str_detect(primer, "I")) {
        message(paste0("Warning: Inosine (I) bases detected in primer ", primer," these will be converted to N!"))
        primer <- primer %>% str_replace_all("I", "N")
        }
    # Counts number of sequences in which the primer is found
    nhits <- vcountPattern(primer, sread(readFasta(fn)), max.mismatch=max.mismatch, fixed = FALSE, with.indels = with.indels)
    return(sum(nhits > 0))
}

primers <- read_csv("primer_evaluation/primer_candidates.csv") %>%
  distinct()

target="reference/merged_final.fa.gz"

out <- vector("list", length=nrow(primers))
for (i in 1:nrow(primers)){
  
  if(primers$strand[i] == "F"){
    query <- primers$seq[i]
    
  } else  if(primers$strand[i] == "R"){
    query <- rc(primers$seq[i])
  }
  print(i)
  df <- tibble(
    name = primers$name[i],
    primer = query,
    strand = primers$strand[i],
    #Hamming distance (no indels in COI)
    #h0 = primerHits(query, target, max.mismatch=0, with.indels=FALSE),
    #h1 = primerHits(query, target, max.mismatch=1, with.indels=FALSE),
    h2 = primerHits(query, target, max.mismatch=2, with.indels=FALSE),
  )
  out[[i]] <- df
}

names(out) <- primers$seq
out <- bind_rows(out)
write_csv(out, "primer_evaluation/primer_presence.csv")

# Plotting
out <- read_csv("primer_evaluation/primer_presence.csv") %>% 
  pivot_longer(cols=starts_with(c("h", "l")),
               names_to = "measure",
               values_to = "seqs"
               ) %>%
  filter(measure=="h2") %>%
  mutate(name = factor(name)) %>%
  arrange(name)

gg.primerpresF <- out %>%
  left_join(primers) %>%
  filter(strand=="F") %>%
    mutate(name = fct_reorder(name, seqs, .desc = TRUE)) %>%
  ggplot(aes(x=name, y=seqs, fill=seqs)) + 
  geom_bar(stat="identity", position="dodge") +
  coord_flip() + 
  labs(x="Forward Primers", y=NULL)  +
  base_theme +
  scale_y_continuous(labels = scales::label_number_si())+
  scale_fill_gradient(low = "firebrick", high = "darkslateblue", 
                      na.value = "grey", oob = scales::squish) 

gg.primerpresR <- out  %>%
  left_join(primers) %>%
  filter(strand=="R") %>%
    mutate(name = fct_reorder(name, seqs, .desc = TRUE)) %>%
  ggplot(aes(x=name, y=seqs, fill=seqs)) + 
  geom_bar(stat="identity", position="dodge") +
  coord_flip() + 
  labs(x="Reverse Primers", y="# Sequences containing primers") +
  base_theme +
  scale_y_continuous(labels = scales::label_number_si()) +
  scale_fill_gradient(low = "firebrick", high = "darkslateblue", 
                      na.value = "grey", oob = scales::squish) 

gg.primerpres <- gg.primerpresF / gg.primerpresR

gg.primerpres

# add counts primers
primers %>%
  left_join(out %>% select(name, seqs)) %>%
  write_csv("primer_evaluation/primer_candidates.csv")

pdf(file="fig/supplementary/primerpres.pdf", width = 8, height = 11 , paper="a4")
  plot(gg.primerpres)
try(dev.off(), silent=TRUE)

```

# Overview of COI

## Entropy
```{r Entropy}
# Get whole alignment entropy
seqs <- insect::readFASTA("reference/merged_final.fa.gz")
seqs <- seqs[lengths(seqs)==712]

## Entropy by individual order
queryrank <- "order"

# Get unique querieranks
queries <- names(seqs)  %>% 
  str_split_fixed(";", n = 8) %>% 
  as_tibble() %>% 
  magrittr::set_colnames(c("acc", "kingdom", "phylum",
                           "class", "order", "family", 
                           "genus", "species")) %>%
  filter(class %in% c("Insecta", "Arachnida")) %>%
  pull(queryrank) %>%
  unique()

#Make lists to store everything
entlist <- vector("list", length=length(queries))
names(entlist) <- queries

for (i in 1:length(queries)){
  print(i)
  query <- queries[i]
 print(query)
 
 subset <- filter_by_tax(seqs, filtrank=queryrank, filtvalue=query)
  if (length(subset) > 0){
    nseqs <- length(subset)
    message(nseqs, " sequences for ", query)
    # Get entropies
    entlist[[i]] <- taxreturn::alignment_entropy(as.list(subset), maskgaps=1, countgaps=FALSE, 
                                        method="ML", unit="log", return_extra = TRUE)
  }
}

ent_out <- bind_rows(entlist, .id="names")
write_csv(ent_out, paste0("primer_evaluation/", queryrank,"_ent_out.csv"))

# Read in per order entropy
ent <- read_csv("primer_evaluation/order_ent_out.csv") %>% 
  filter(bases > 20) # Filter to only those above 20 seqs

#Set moving average function - Adjust smoothing (n=5?)
ma <- function(x, n=3){stats::filter(x, rep(1/n, n), sides=2)}

ent_smoothed <- ent %>%
  mutate(ent = ent %>% 
           na_if("") %>%
           replace_na(0)) %>%
  mutate(ma = ma(ent, n = 3)) %>%
  mutate(ma = ma %>% replace_na(0)) %>%
  mutate(annot = case_when(
    pos %in% seq(from=1, to=2, by=1) ~ "Loop 0",
    pos %in% seq(from=3, to=78, by=1) ~ "Helix 1",
    pos %in% seq(from=79, to=103, by=1)~ "Loop 1-2",
    pos %in% seq(from=104, to=211, by=1)~ "Helix 2",    
    pos %in% seq(from=212, to=235, by=1)~ "Loop 2-3",   
    pos %in% seq(from=213, to=304, by=1)~ "Helix 3", 
    pos %in% seq(from=305, to=373, by=1)~ "Loop 3-4", 
    pos %in% seq(from=374, to=466, by=1)~ "Helix 4", 
    pos %in% seq(from=467, to=499, by=1)~ "Loop 4-5", 
    pos %in% seq(from=500, to=598, by=1)~ "Helix 5", 
    pos %in% seq(from=599, to=634, by=1)~ "Loop 5-6", 
    pos %in% seq(from=635, to=712, by=1)~ "Helix 6", 
  )) %>%
  mutate(structure = case_when(
    str_detect(annot, "Helix") ~ "Helix",
    str_detect(annot, "Loop") ~ "Loop",
  ))  

## plot entropy by order
colourCount = length(unique(ent_smoothed$names))
getPalette = colorRampPalette(brewer.pal(9, "Paired"))

gg.separate_ent <- ent_smoothed %>%
  group_by(pos) %>%
  mutate(median = median(ma)) %>%
  ggplot(aes(x = pos, y=ma, colour=names)) + 
  geom_line(aes(x = pos, y=ma)) +
  facet_wrap(~names, ncol=3) +
  base_theme +
  labs(
    x="Position within COI barcode locus",
    y="Shannons Entropy (H)")  +
  scale_color_manual(values = getPalette(colourCount))+
  scale_x_continuous(limits = c(0, 712), expand=c(0,0))

gg.separate_ent
pdf(file="fig/supplementary/all_orders_entropy.pdf", width = 8, height = 11 , paper="a4")
  plot(gg.separate_ent)
try(dev.off(), silent=TRUE)


# Plot entropy of COI Gene
gg.entropy <- ent_smoothed %>%
  group_by(pos) %>%
  mutate(median = median(ma)) %>%
  ggplot(aes(x = pos, y=ma, group=pos, colour=structure)) + 
  geom_boxplot(outlier.shape = NA, alpha=0.8) +
  geom_line(aes(x = pos, y=median),size=1, inherit.aes = FALSE) + #, colour="black"
  theme_classic() +    
  theme(legend.position = "none",
        axis.ticks.x = element_blank(),
        axis.text.x = element_blank(),
        axis.title.x = element_blank()) +
  labs(
    x="Position within COI barcode locus",
    y="Shannons Entropy (H)",
    colour="3D structure") +
  scale_color_manual(values=c("#e31a1c","#1f78b4")) +
  scale_x_continuous(limits = c(0, 712), breaks=seq(0,700,50), expand=c(0,0)) 

# Plot number of sequence across whole gene
gg.sequences <- ent_smoothed %>%
  group_by(pos) %>%
  summarise(bases = sum(bases), structure) %>%
  ggplot(aes(x = pos, y=bases)) + 
  geom_line()+
  #geom_boxplot(outlier.shape = NA, alpha=0.8) +
  theme_classic() +    
  theme(legend.position = "none") +
  labs(
    x="Position within COI barcode locus",
    y="# Sequences", colour=NULL) +
  scale_x_continuous(limits = c(0, 712), breaks=seq(0,700,50), expand=c(0,0), labels=scales::unit_format(unit="bp")) +
  scale_y_continuous(labels = scales::label_number_si())+
  scale_color_manual(values=c("#e31a1c","#1f78b4"))  



## Primers
range_join <- function(x, y, value, range_start, range_stop){
  if(!any(stringr::str_detect(colnames(y), range_start)) | !any(stringr::str_detect(colnames(y), range_stop))){
    stop("Arguments range_start and range_stop must be valid columns in y")
  }
  splits <- split(y, 1:nrow(y))
  out <- tibble()
  for (i in 1:length(splits)){ 
    y_ <- splits[[i]]
    dat <- x[x[[value]] >= y_[[range_start]] & x[[value]] < y_[[range_stop]],]     
    if(nrow(dat) > 0)      
      out <-  out %>% bind_rows(dat %>% cbind(y_))  
  }
  return(out)
}

primers <- read_csv("primer_evaluation/primer_candidates.csv") %>% 
  distinct()

#Add ranks in overlapping windows to arrange y by
windowsize=130

primer_windows <- primers %>%
  range_join(
    enframe(seq(min(primers$start), max(primers$end + 100), by = windowsize)) %>%
    dplyr::rename(window= name, winend=value) %>%
    mutate(winstart = winend - windowsize), value="start", range_start="winstart", range_stop="winend") %>%
  group_by(window) %>%
  arrange(start) %>%
  mutate(rank=row_number()) %>%
  ungroup()

gg.primers <- ggplot(data=ent_smoothed[ent_smoothed$pos==1,], aes(x = as.numeric(pos))) +
  geom_segment(data = primer_windows %>% filter(strand=="F"),
               aes(x = start, xend = end,
                   y = rank, yend = rank,
                   colour=strand), size = 1, arrow = arrow(length = unit(0.3,"cm")),
               show.legend = FALSE) +
  geom_text(data = primer_windows %>% filter(strand=="F"),
            aes(x = start, y = rank,
                label = name , colour=strand),
            hjust = 1, show.legend = FALSE) +
  geom_segment(data = primer_windows %>% filter(strand=="R"),
               aes(x = end, xend = start,
                   y = rank, yend = rank,
                   colour=strand), size = 1,
               arrow = arrow(length = unit(0.3,"cm")),
               show.legend = FALSE) +
  geom_text(data = primer_windows %>% filter(strand=="R"),
            aes(x = end, y = rank,
                label = name, colour=strand),
            hjust = 0, show.legend = FALSE)  +
  scale_x_continuous(limits = c(0, 712), breaks=seq(0,700,50), expand=c(0,0)) +
  theme_void()+
    labs(x="Position within COI barcode locus", y=NULL, colour=NULL)  +
  scale_color_manual(values=c("#e31a1c","#1f78b4"))

gg.primers


# Test of entropy between loops and helices
t.test(ent_smoothed %>% filter(structure=="Loop") %>% pull(ent), ent_smoothed %>% filter(structure=="Helix") %>% pull(ent)) %>%
  broom::tidy()
```

# Sliding window

## Sliding window PCR

```{r make windows}
# Load seqs
seqs <- readDNAStringSet("reference/merged_final.fa.gz")
seqs <- seqs[lengths(seqs)==712]
# Sliding window
alignment_sw <- function(x, width, interval = 1, maxgaps=0){
  alignment_width <- max(width(x))
  win <- seq(1,  alignment_width - width, by = interval) #Get all possible windows
  out <- vector("list", length=length(win))
  for(i in 1:length(win)){
    amplicon <- Biostrings::subseq(x, start=win[i], end = win[i]+width) #may need to add 1 to start
    rem <- names(amplicon)[Biostrings::letterFrequency(amplicon, "-") > maxgaps]
    amplicon <- amplicon[!names(amplicon) %in% rem]
    out[[i]] <- amplicon
  }
  names(out) <- paste(win, win+width, sep="-")
  return(out)
}

# Make 200bp windows
dir.create("primer_evaluation/amplicons/win200/")
alignment_sw(seqs, width=200, interval=3, maxgaps=9) %>%
  purrr::map2(., names(.), ~Biostrings::writeXStringSet(.x, file=paste0("primer_evaluation/amplicons/win200/", .y,".fa.gz"), compress=TRUE))

# Make 300bp windows
dir.create("primer_evaluation/amplicons/win300/")
alignment_sw(seqs, width=300, interval=3, maxgaps=9) %>%
  purrr::map2(., names(.), ~Biostrings::writeXStringSet(.x, file=paste0("primer_evaluation/amplicons/win300/", .y,".fa.gz"), compress=TRUE))

# Make 400bp windows
dir.create("primer_evaluation/amplicons/win400/")
alignment_sw(seqs, width=400, interval=3, maxgaps=9) %>%
  purrr::map2(., names(.), ~Biostrings::writeXStringSet(.x, file=paste0("primer_evaluation/amplicons/win400/", .y,".fa.gz"), compress=TRUE))

```
 
 
## USEARCH distance matrix

```{bash}
#!/bin/bash
dos2unix bash/usearch_distmat.sh
/usr/bin/ls -d /group/pathogens/Alexp/Metabarcoding/primer_evaluation/primer_evaluation/amplicons/win*/* | sed -e '1p' -e '/.fa.gz/!d' | sort -u > job_index.txt
njobs=$(cat job_index.txt | wc -l)
sbatch --array=1-$njobs bash/usearch_distmat.sh
```


# Fig2 - COI Overview

```{r coi overview}
# Summarise number of mixed clusters that contain pests at %
pestlist <- read_csv("primer_evaluation/pestlist.csv") 

# Get mixed clusters
library(furrr)
plan(multiprocess, workers=8)
sw_clusters <- c(fs::dir_ls(path="primer_evaluation/amplicons/win200/usearch_output/", glob = "*.txt.gz"),
                    fs::dir_ls(path="primer_evaluation/amplicons/win300/usearch_output/", glob = "*.txt.gz"),
                    fs::dir_ls(path="primer_evaluation/amplicons/win400/usearch_output/", glob = "*.txt.gz")) %>%
  furrr::future_map(function(x){
  #purrr::map(function(x){
  vroom::vroom(x, delim="\t", col_names = c("acc1", "acc2", "dist")) %>%
    dplyr::mutate(spp1 = acc1 %>%
                    str_remove(";$") %>%
                    str_remove("^.*;"),
                  acc1 = acc1 %>% str_remove(";.*$"),
                  spp2 = acc2 %>%
                    str_remove(";$") %>%
                    str_remove("^.*;"),
                  acc2 = acc2 %>% str_remove(";.*$"),
                  dist = round(dist, 2)) %>%
    dplyr::filter(dist %in% c(0.03, 0.02,0.01, 0)) %>%
    dplyr::filter(!spp1==spp2) %>%
    dplyr::mutate(id_0.97 = case_when(dist <=0.03~ TRUE, TRUE ~ FALSE),
                  id_0.98 = case_when(dist <=0.02~ TRUE, TRUE ~ FALSE),
                  id_0.99 = case_when(dist <=0.01~ TRUE, TRUE ~ FALSE),
                  id_1 = case_when(dist == 0~ TRUE, TRUE ~ FALSE)) %>%
  pivot_longer(cols = starts_with("id"),
               names_to = "threshold",
               values_to= "outcome") %>%
  mutate(threshold = threshold %>% str_remove("id_")) %>%
  filter(outcome == TRUE)  %>%
        dplyr::group_by(threshold) %>% 
        dplyr::summarise(mixed=n_distinct(spp1))
    
  })%>%
  bind_rows(.id="source") %>%
  mutate(source = str_remove(basename(source), ".txt.gz")) %>%
  mutate(win_start = source %>% str_remove("-.*$")  %>% as.numeric(),
         win_end = source %>% str_remove("^.*-") %>% as.numeric()) %>%
  mutate(win_length = win_end - win_start)
  
#Get amplified
amplified <-c(fs::dir_ls(path="primer_evaluation/amplicons/win200/", glob = "*.fa.gz"),
              fs::dir_ls(path="primer_evaluation/amplicons/win300/", glob = "*.fa.gz"),
              fs::dir_ls(path="primer_evaluation/amplicons/win400/", glob = "*.fa.gz")) %>%
   purrr::map(function(x){
   #furrr::future_map(function(x){
     fasta.index(x) %>%
        mutate(species = desc %>% 
                 str_remove("(?:[^;]*;){7}") %>% #match 7th ;
                 str_remove(";$"))  %>%
      dplyr::group_by(filepath) %>%
      dplyr::summarise(seqs_amplified = n(), spp_amplified = n_distinct(species)) 
   }) %>%
  bind_rows() %>%
  mutate(source = str_remove(basename(filepath), ".fa.gz")) %>%
  dplyr::select(-filepath)

sw_joint <- sw_clusters %>%
  left_join(amplified) 
vroom::vroom_write(sw_joint, "primer_evaluation/amplicons/sw_clusters_summary2.csv", delim=",")

# Read in
sw_joint <- vroom::vroom("primer_evaluation/amplicons/sw_clusters_summary2.csv", delim=",") %>%
  mutate(pos = win_start) %>%
  mutate(success =  (spp_amplified - mixed)/spp_amplified)

# New plot
sw_means <- sw_joint %>%
  filter(win_start > 25, win_end < (712-26)) %>%
  group_by(source, threshold) %>%
  group_split() %>%
  purrr::map(function(x){
    x %>% dplyr::slice(rep(1:n(), each = unique(x$win_length))) %>%
      mutate(pos = seq(unique(x$win_start) , (unique(x$win_end)-1), 1))
  }) %>%
  bind_rows() %>%
  ungroup() %>%
  group_by(threshold, pos, win_length) %>%
  summarise(success = mean(success))

gg.swid <- sw_means %>%
    filter(threshold == 0.97) %>%
    ggplot(aes(x = pos, y=1)) +
      geom_tile(aes(fill=success))+
      scale_fill_viridis_c(option="plasma", labels = scales::percent) + 
    facet_wrap(win_length ~., ncol=1, strip.position ="left") +
    scale_x_continuous(limits = c(0, 712), breaks=seq(0,700,50), expand=c(0,0))  +
    theme_void() +
    theme(legend.position = "right",
          axis.text.y = element_blank(),
          axis.ticks.y = element_blank()) +
  labs(fill = "% Identified",
       y = "Window size")


Fig2 <-  gg.primers / gg.entropy / gg.swid / gg.sequences  + plot_layout(heights= c(3, 3, 2, 0.5))   +  plot_annotation(tag_levels = 'A') 


pdf(file="fig/Fig2_COI_overview.pdf", width = 11, height = 8 , paper="a4r")
  plot(Fig2)
try(dev.off(), silent=TRUE)

# Regression
sw_means %>%
  ggplot(aes(x=pos, y=success))+
  geom_point(alpha=0.2)+
  geom_smooth(method="lm")+
  facet_grid(threshold~win_length)

sw_means %>%
  group_by(threshold,win_length) %>%
  nest() %>%
  mutate(fit_lm = purrr::map(data, ~lm(success~pos, data = .)),
         coef_info = purrr::map(fit_lm, broom::tidy)) %>%
  unnest(coef_info) %>%
  View() 

```


# ID Success by primer
 
## Virtual PCR

```{r Virtual PCR}
# Load seqs
seqs <- readDNAStringSet("reference/merged_final.fa.gz")
seqs <- seqs[lengths(seqs)==712]

# Load primers
primers <- read_csv("primer_evaluation/primer_candidates.csv") %>%
  mutate(seq = str_replace_all(seq, "I","N")) %>% 
  select(-starts_with(c("score", "issues")))

# Get all possible primer combinations
combos <- expand_grid(primers %>% filter(strand=="F") %>% pull(seq),
                      primers %>% filter(strand=="R") %>% pull(seq)
                      ) %>%
  mutate_if(is.factor, as.character)%>%
  unique() %>%
  magrittr::set_colnames(c("Fseq", "Rseq")) %>%
  left_join(primers %>% filter(strand=="F") %>% rename_all(. %>% paste0("F",.)), by="Fseq") %>%
  left_join(primers %>% filter(strand=="R") %>% rename_all(. %>% paste0("R",.)), by="Rseq") %>%
  mutate(amplicon = Rstart - Fend) %>%
  filter(amplicon > 50)

dir.create("primer_evaluation/amplicons")

# Setup multithreading
library(foreach)
library(doParallel)
cores=12
cl <- parallel::makeCluster(cores)
registerDoParallel(cl)

li <- foreach(p=1:nrow(combos)) %dopar% {
  #get primer names
  primernames <- paste0(combos$Fname[p], "_",  combos$Rname[p])
  
  # cut down alignments
  amplicon <- Biostrings::subseq(seqs, start=combos$Fend[p]+1, end = combos$Rstart[p]) #may need to add 1 to start
  
  if (any(!lengths(amplicon)== combos$amplicon[p])){
    warning(paste0("Amplicons of ",primernames, " are not the same length"))
  }
  
  maxgaps <- 9 # dont allow any more than 9 gaps
  rem <- names(amplicon)[Biostrings::letterFrequency(amplicon, "-") > maxgaps]
  amplicon <- amplicon[!names(amplicon) %in% rem]
  message(paste0(length(rem), " Sequences with more than ", maxgaps, " gaps removed from ", primernames))
  
  #write out sequences
  Biostrings::writeXStringSet(amplicon, file=paste0("primer_evaluation/amplicons/", primernames,".fa.gz"), compress=TRUE)
}
#close cluster
parallel::stopCluster(cl)
```


## USEARCH distance matrix

```{bash}
#!/bin/bash
dos2unix bash/usearch_distmat.sh
/usr/bin/ls -d /group/pathogens/Alexp/Metabarcoding/primer_evaluation/primer_evaluation/amplicons/* | sed -e '1p' -e '/.fa.gz/!d' | sort -u > job_index.txt
/usr/bin/ls -d /group/pathogens/Alexp/Metabarcoding/primer_evaluation/primer_evaluation/amplicons/win*/* | sed -e '1p' -e '/.fa.gz/!d' | sort -u > job_index.txt
njobs=$(cat job_index.txt | wc -l)
sbatch --array=1-$njobs bash/usearch_distmat.sh
```

# Fig 3 - ID success for different primers

```{r id success}
# Summarise number of mixed clusters that contain pests at %
pestlist <- read_csv("primer_evaluation/pestlist.csv") 

# Load primers
primers <- read_csv("primer_evaluation/primer_candidates.csv") %>%
  mutate(seq = str_replace_all(seq, "I","N"))  %>%
  distinct()

# Get all possible primer combinations
combos <- expand_grid(primers %>% filter(strand=="F") %>% pull(seq),
                      primers %>% filter(strand=="R") %>% pull(seq)
                      ) %>%
  mutate_if(is.factor, as.character)%>%
  unique() %>%
  magrittr::set_colnames(c("Fseq", "Rseq")) %>%
  left_join(primers %>% filter(strand=="F") %>% rename_all(. %>% paste0("F",.)), by="Fseq") %>%
  left_join(primers %>% filter(strand=="R") %>% rename_all(. %>% paste0("R",.)), by="Rseq") %>%
  mutate(amplicon = Rstart - Fend) %>%
  filter(amplicon > 50)

# Check missing
complete <- list.files(path="primer_evaluation/amplicons/usearch_output/", pattern = ".txt.gz") %>%
  basename %>%
  str_remove(".txt.gz")

setdiff(paste0(combos$Fname, "_",  combos$Rname), complete)
setdiff(complete,paste0(combos$Fname, "_",  combos$Rname))


# Get mixed clusters
library(furrr)
plan(multiprocess, workers=12)
mixed_clusters <- fs::dir_ls(path="primer_evaluation/amplicons/usearch_output/", glob = "*.txt.gz")%>%
  furrr::future_map(function(x){
  #purrr::map(function(x){
  df <- vroom::vroom(x, delim="\t", col_names = c("acc1", "acc2", "dist")) %>%
    dplyr::mutate(spp1 = acc1 %>%
                    str_remove(";$") %>%
                    str_remove("^.*;"),
                  acc1 = acc1 %>% str_remove(";.*$"),
                  spp2 = acc2 %>%
                    str_remove(";$") %>%
                    str_remove("^.*;"),
                  acc2 = acc2 %>% str_remove(";.*$"),
                  dist = round(dist, 2)) %>%
    filter(dist %in% c(0.03, 0.02,0.01, 0)) %>%
    dplyr::filter(!spp1==spp2) %>%
    dplyr::mutate(id_0.97 = case_when(dist <=0.03~ TRUE, TRUE ~ FALSE),
                  id_0.98 = case_when(dist <=0.02~ TRUE, TRUE ~ FALSE),
                  id_0.99 = case_when(dist <=0.01~ TRUE, TRUE ~ FALSE),
                  id_1 = case_when(dist == 0~ TRUE, TRUE ~ FALSE)) %>%
  pivot_longer(cols = starts_with("id"),
               names_to = "threshold",
               values_to= "outcome") %>%
  mutate(threshold = threshold %>% str_remove("id_")) %>%
  filter(outcome == TRUE) 

  all <- df %>%
        dplyr::group_by(threshold) %>% 
        dplyr::summarise(mixed=n_distinct(spp1)) %>%
        dplyr::mutate(type="all")
  pests <- df %>%
        dplyr::group_by(threshold) %>% 
        filter(spp1 %in% pestlist$Species) %>%
        dplyr::summarise(mixed=n_distinct(spp1)) %>%
        dplyr::mutate(type="pest")
  out <- bind_rows(all, pests)
  return(out)
  
  })%>%
  bind_rows(.id="source") %>%
  mutate(source = str_remove(basename(source), ".txt.gz"))
  
#Get amplified
amplified <- fs::dir_ls(path="primer_evaluation/amplicons/", glob = "*.fa.gz") %>%
   purrr::map(function(x){
   #furrr::future_map(function(x){
     df <- fasta.index(x) %>%
        mutate(species = desc %>% 
                 str_remove("(?:[^;]*;){7}") %>% #match 7th ;
                 str_remove(";$")) # match last ;
     all <- df %>%
      dplyr::group_by(filepath) %>%
      dplyr::summarise(seqs_amplified = n(), spp_amplified = n_distinct(species)) %>%
      dplyr::mutate(type="all")
     pests <- df %>%
      dplyr::group_by(filepath) %>%
      dplyr::filter(species %in% pestlist$Species) %>%
      dplyr::summarise(seqs_amplified = n(), spp_amplified = n_distinct(species)) %>%
      dplyr::mutate(type="pest")
     out <- bind_rows(all, pests)
    return(out)
   }) %>%
  bind_rows() %>%
  mutate(source = str_remove(basename(filepath), ".fa.gz")) %>%
  dplyr::select(-filepath)

joint <- mixed_clusters %>%
  left_join(amplified) %>%
  mutate(combos = source) %>% 
  tidyr::separate(source, into=c("Fname", "Rname"), sep="_", extra="merge")
#vroom::vroom_write(joint, "primer_evaluation/amplicons/mixed_clusters_summary.csv", delim=",")


# Make figure
joint <- vroom::vroom("primer_evaluation/amplicons/mixed_clusters_summary.csv", delim=",") %>%
  left_join(combos) %>% 
  mutate(success =  (spp_amplified - mixed)/spp_amplified) %>%
  dplyr::select(Fname,Rname,  threshold,
                mixed, type, seqs_amplified,
                spp_amplified, amplicon, combos, success) 


# Look at log ratio to the folmer region
ref <- joint %>% 
  dplyr::filter(Fname == "LCO1490"&  Rname=="HCO2198") %>% 
              select(ref_success = success,
                     threshold, type) %>%
  dplyr::filter(threshold %in% c(0.97,0.98,0.99, 1))%>%
  group_by(type) %>%
  summarise(ref_success = mean(ref_success)) %>%
  ungroup()

id_success <- joint %>% 
  dplyr::filter(threshold %in% c(0.97,0.98,0.99, 1))%>%
  group_by(Fname, Rname, type, combos, amplicon, threshold) %>%
  summarise(success = mean(success)) %>%
  ungroup() %>%
  left_join(ref) %>%
  mutate(success_alr = log(success/ref_success),
         success_rat = success/ref_success,
         highlight = case_when(
           combos %in% c("fwhF2_fwhR2n", "fwhF2_HexCOIR4") ~ TRUE,
           TRUE ~ FALSE
         ))%>%
    mutate(type = type %>% str_replace("all", "All Insects") %>% str_replace("pest", "Pest Insects"))


# Breakpoint regression
set.seed(666)
model_dat <- id_success %>%
  dplyr::select(combos, amplicon, threshold, success, success_alr, success_rat, type)

# SOme amplicon lengths are missing so getitng NAs

library(chngpt)
breakpoint_fit <- model_dat %>% 
  group_by(threshold, type) %>%
  nest() %>%
  mutate(fits = purrr::map(data, ~chngptm(formula.1=success~1, formula.2=~amplicon,
                                   type="segmented", family="gaussian",data = .)),
         summary = purrr::map(fits, summary),
         #preds = map2(fits, data, predict),
         aug = purrr::map2(fits, data, function(x,y){
           preds <- predict(x,y)
           out <- y
           out$preds <- preds
           out$res <- NA
           out$res[!is.na(out$preds)] <- resid(x)
           return(out)
           }),
         breakpoint = purrr::map(fits, "chngpt"),
         breakpoint_ests = purrr::map(summary, function(x){ as.data.frame(t(x$chngpt))}),
         coef_info = purrr::map(summary,function(x){ as_tibble(x$coefficients, rownames="term" )})
         )
  
# Get SE of breakpoints
breakpoint_fit %>% 
  unnest(breakpoint_ests) %>% 
 select(-where(is.list)) 

slope_coefs <- breakpoint_fit %>%
  unnest(coef_info) %>%
  dplyr::select(threshold,term, est, std_err = `Std. Error*`,
                lower = `(lower`, upper = `upper)`,
                pval = `p.value*`, -where(is.list), type) %>%
  mutate(
    term = case_when(
    term == "(Intercept)" ~  "intercept",
    term == "amplicon" ~  "slope",
    term == "(amplicon-chngpt)+" ~ "post_slope"
    )) %>%
  mutate(signif = pval < 0.05) 


dat_pred <- breakpoint_fit %>%
  unnest(aug, breakpoint)%>%
  select(-where(is.list))  %>%
  drop_na() %>%
  left_join(slope_coefs %>%
              select(threshold, term, signif, est) %>%
              pivot_wider(names_from=term, values_from=c(signif, est))) 


break_annot <- dat_pred %>% 
  group_by(threshold, type) %>%
  filter(amplicon == breakpoint) %>%
  dplyr::slice(1) %>%
  select(-combos) %>%
  left_join(slope_coefs %>%
              filter(term == "post_slope") %>%
              select(threshold, pval, signif))

# Highest success
ref_annot <- id_success %>%
  group_by(threshold, type) %>%
  filter(combos == "LCO1490_HCO2198")

gg.id <- id_success %>%
  left_join(dat_pred) %>%
  ggplot(aes(x=amplicon, y=success, colour=res))+
    geom_vline(data=dat_pred, aes(xintercept = breakpoint), colour="black", linetype = "dashed") +
  geom_jitter(width = 5, height=0.01, alpha=0.4)+
  geom_line(data=dat_pred[dat_pred$amplicon < dat_pred$breakpoint,],
             aes(x=amplicon, y=preds),  color = 'red', inherit.aes = FALSE) +
  geom_line(data=dat_pred[dat_pred$amplicon >= dat_pred$breakpoint,],
            aes(x=amplicon, y=preds),  color = 'red', inherit.aes = FALSE) +
  geom_point(data=break_annot, aes(x=amplicon, y=preds),  color = 'red', inherit.aes = FALSE) +
  geom_text(data=break_annot, aes(x=amplicon, y=preds,
                                  label=paste0(breakpoint, "bp")), #,ifelse(pval < 0.001,"<0.001", ">0.001")
            nudge_y = 0.1,nudge_x = 10,  color = 'red', inherit.aes = FALSE) +
  geom_text(data=ref_annot, aes(x=amplicon, y=success,label=paste0("Max: ",round((success* 100),1), "%")),
            nudge_y = 0.05, nudge_x = -100,  color = 'blue', inherit.aes = FALSE) +
  scale_colour_viridis_c(option="D", labels =scales::percent_format(accuracy=1))+
  base_theme+
  facet_grid(type~threshold) +
  coord_cartesian(ylim=c(0.5,1))+
  scale_linetype_manual(values=c( "dashed", "solid"))+
  scale_y_continuous(labels = scales::percent) +
  scale_x_continuous(labels=scales::unit_format(unit="bp"))+
  theme(panel.grid.minor = element_blank(),
        legend.position = "bottom",
        strip.background = element_rect(colour = "black", fill = "lightgray"),
        strip.text = element_text(size=9, family = ""))+ 
  labs(x="Amplicon length",
       y="Successfully identified",
       colour= "Residuals") 

gg.id

pdf(file="fig/Fig3_id_success_length.pdf", width = 11, height = 6 , paper="a4r")
  plot(gg.id)
try(dev.off(), silent=TRUE)
  

# Residuals summary for fig6
id_success %>%
  left_join(dat_pred) %>%
  mutate(type = type %>% str_replace("all", "All Insects") %>% str_replace("pest", "Pest Insects") %>% as.factor()) %>%
  write_csv("primer_evaluation/residuals_summary.csv")

  
# Residuals plot  
  library(tidytext)
test <- id_success %>%
  left_join(dat_pred) %>%
  mutate(type = type %>% str_replace("all", "All Insects") %>% str_replace("pest", "Pest Insects") %>% as.factor()) %>%
  group_by(combos, type) %>%
  summarise(res = mean(res)) %>%
  ungroup()%>%
  mutate(combos= reorder_within(combos, -res, type)) %>%
  ggplot(aes(x = combos, y=res, colour=res)) +
  geom_segment( aes(xend=combos,y=0, yend=res))+
  geom_point(colour="black") + 
  scale_x_reordered() +
  scale_colour_viridis_c(option="D")+
  scale_fill_viridis_c(option="D")+
  facet_wrap(type~., ncol=1)+
  base_theme +
  theme(axis.text.x = element_blank(),
        panel.grid = element_blank())
  
library(plotly)
ggplotly(test)
```

# Fig 4 - Fullength phylo

```{r ID success on tree}
# Autocorrelation
tree <- ape::read.tree("reference/trees/ultrametric_insecta_tree_order_constrained.nwk")

# get Lineage for tree
seqs <- insect::readFASTA("reference/merged_final.fa.gz")
seqs <- acc2hex(seqs)
lineage <- names(seqs) %>%
  str_split_fixed(pattern="\\|", n = 2) %>%
  as_tibble() %>%
  separate(V2, into=c("taxid","Kingdom", "Phylum", 
    "Class", "Order", "Family", "Genus", "Species"), sep=";") %>%
  dplyr::rename(acc = V1)%>%
  mutate(Species = Species %>% str_replace_all(" ", "_")) %>%
  dplyr::select(-Species)

# Get mixed clusters for the LCO-HCO gene region
folmer_id_spp <- vroom::vroom("primer_evaluation/amplicons/usearch_output/LCO1490_HCO2198.txt.gz",
                          delim="\t", col_names = c("acc1", "acc2", "dist")) %>%
    dplyr::mutate(spp1 = acc1 %>%
                    str_remove(";$") %>%
                    str_remove("^.*;"),
                  acc1 = acc1 %>% str_remove(";.*$"),
                  spp2 = acc2 %>%
                    str_remove(";$") %>%
                    str_remove("^.*;"),
                  acc2 = acc2 %>% str_remove(";.*$"),
                  dist = round(dist, 2)) %>%
    filter(dist %in% c(0.03, 0.02,0.01, 0)) %>%
    dplyr::filter(!spp1==spp2) %>%
    dplyr::mutate(id_0.97 = case_when(dist <=0.03~ TRUE, TRUE ~ FALSE),
                  id_0.98 = case_when(dist <=0.02~ TRUE, TRUE ~ FALSE),
                  id_0.99 = case_when(dist <=0.01~ TRUE, TRUE ~ FALSE),
                  id_1 = case_when(dist == 0~ TRUE, TRUE ~ FALSE)
    )%>%
  pivot_longer(cols = starts_with("id"),
               names_to = "threshold",
               values_to= "outcome") %>%
  mutate(threshold = threshold %>% str_remove("id_")) %>%
  filter(outcome == TRUE) %>%
    dplyr::group_by(threshold, acc1, spp1) %>% 
    dplyr::summarise(mixed=n_distinct(spp2)) %>%
    ungroup() %>%
  mutate(tips = paste0(acc1 %>% str_remove("\\|.*$") %>% acc2hex(.), "|", spp1 %>% str_replace_all(" ", "_"))) %>%
  select(threshold, tips, values = mixed)

# Colour palette for orders
main_orders <- lineage  %>%
  filter(Class=="Insecta") %>%
  group_by(Order) %>%
  summarise(n=n()) %>%
  filter(n > 100)

getPalette <- colorRampPalette(brewer.pal(12, "Paired"))
order_pal <- getPalette(nrow(main_orders))
names(order_pal) <- main_orders$Order

# Number of fialed ID's per order plot
library(tidytext)
gg.failed <- folmer_id_spp %>%
  separate(tips, into=c("acc", "species"), sep="\\|") %>%
  left_join(lineage) %>%
  filter(threshold=="0.97")%>%
  filter(Class =="Insecta") %>%
  mutate(values = case_when(values > 1 ~ 1, TRUE ~ 0)) %>%
  group_by(Order) %>%
  summarise(values = sum(values)) %>%
  ungroup() %>%
  top_n(10, values) %>%
  mutate(Order = factor(Order)) %>%
  ggplot(aes(x = fct_reorder(Order, values, sum), y = values , fill=Order))+
  geom_col()+
  scale_fill_manual(values=order_pal) +
  # scale_fill_brewer(palette = "Paired")+
  scale_x_reordered()+
  base_theme +
  theme(legend.position = "none") +
  labs(x = "Taxonomic order",
       y= "Faied ID's per order")
  
gg.failed

thresholds <- unique(folmer_id_spp$threshold)
acfvec <- traitvec <- trait_signif <- vector("list", length = length(thresholds))
names(acfvec) <- names(traitvec) <- names(trait_signif) <- thresholds

set.seed(666)
i=1
for(i in 1:length(thresholds)){
  weights <- tree$tip.label %>% 
    enframe() %>% 
    select(-name, tips = value) %>%
      left_join(folmer_id_spp %>% 
                  filter(threshold == thresholds[i]) %>%
                  select(-threshold)) %>%
     mutate(values = replace_na(values, 0))
  
  tip_states <- weights %>%
    dplyr::pull(values)
  names(tip_states) <- weights %>%
    dplyr::pull(tips)
  
  # Binary tip states
  tip_states_binary <- tip_states
  tip_states_binary[tip_states_binary >0] <- 1

  
  # Autocorrelation funciton
  acf <- castor::get_trait_acf(tree, tip_states_binary, Npairs=1e8, Nbins=100)
  
  # Trait depth
  consentrait <- get_trait_depth(tree, tip_states_binary,
                                 min_fraction = 0.5, #90% of clade must be insufficiently ID'd to be problmeatic
                                 count_singletons=FALSE, weighted=TRUE, Npermutations = 1000)
  
  # Create output data frame
  acfvec[[i]] <- data.frame(
    distances = acf$distances,
    acf_acf = acf$autocorrelations,
    acf_mean_abs = acf$mean_abs_differences,
    acf_mean_rel = acf$mean_rel_differences,
    acf_npairs = acf$Npairs_per_distance)
  
  pos_clades <- consentrait$positive_clades
  traitvec[[i]] <-  data.frame(
    pos_clade_id = pos_clades,
    traits_per_pos_clades = consentrait$positives_per_clade[pos_clades],
    mean_depth_pos_clades = consentrait$mean_depth_per_clade[pos_clades]
  )
  
  trait_signif[[i]] <- data.frame(
    mean_depth = consentrait$mean_depth,
    var_depth  = consentrait$var_depth,
    min_depth = consentrait$min_depth,
    max_depth = consentrait$max_depth,
    n_pos = consentrait$Npositives,
    pval = consentrait$P,
    null_depth = consentrait$mean_random_depth
  )

}

# Try pruning tree to species?

# Phylogenetic conservatism
trait_signif%>%
  bind_rows(.id="threshold") %>%
  mutate(stdev = sqrt(var_depth))

# Autocorrelation
acf <- acfvec %>%
  bind_rows(.id="threshold") %>%
  group_by(threshold) %>%
  pivot_longer(starts_with("acf_"),
               names_to="type",
               values_to="value")


gg.acf <- acf %>% 
  filter(type == "acf_acf", distances < 16) %>%
  filter(threshold==0.97)  %>%
  ggplot(aes(x = distances, y=value, group=threshold)) + #, colour=as.factor(threshold))
  geom_line(colour="darkslateblue") + #
  base_theme+
  #facet_grid(~threshold) +
  theme(legend.position = "none") + 
  labs(x="Phylogenetic distance",
       y="Pearson correlation") +
  scale_y_continuous(labels = scales::percent) #+
  #theme(panel.grid.minor = element_blank())

gg.acf


# Consentrait metric - should this go on the plot?
bad_clades <- traitvec %>%
  bind_rows(.id="threshold") %>%
  filter(threshold==0.97) 
  
outliers <- bad_clades %>%
    group_by(threshold) %>%
  summarise(mean = mean(traits_per_pos_clades), sd = sd(traits_per_pos_clades), zscore = (traits_per_pos_clades - mean(traits_per_pos_clades))/sd(traits_per_pos_clades)) 


#clade labels
bad_clades_labels <- bad_clades %>%
    group_by(threshold) %>%
    mutate(zscore = (traits_per_pos_clades - mean(traits_per_pos_clades))/sd(traits_per_pos_clades)) %>%
    arrange(pos_clade_id, desc(zscore), .by_group = TRUE) %>% 
    mutate(rank = rank(zscore, ties.method = "first")) %>% 
    filter(zscore > 3) %>%
    top_n(20, zscore) %>%
  ungroup() %>%
  mutate(subtree_taxonomy = purrr::map(pos_clade_id,function(x){
    subtree <- castor::get_subtree_at_node(tree, x-Ntip(tree))$subtree
    taxonomy <- subtree$tip.label %>%
      enframe() %>%
      mutate(acc= value %>% str_remove("\\|.*$"))%>%
      left_join(lineage, by="acc")
    print(unique(taxonomy$Genus))
    
    if(length(unique(taxonomy$Genus)) > 1) {
        data.frame(
        subtree_taxonomy = names(which.max(table(taxonomy$Family))),
        order_taxonomy = names(which.max(table(taxonomy$Order)))
                        )
    }else {
        data.frame(
        subtree_taxonomy = names(which.max(table(taxonomy$Genus))),
        order_taxonomy = names(which.max(table(taxonomy$Order)))
                        )
    }
  }))%>% 
  unnest(subtree_taxonomy)%>% 
  right_join(bad_clades_labels) %>%
  mutate(subtree_taxonomy = replace_na(subtree_taxonomy, ""))

library(ggrepel)
library(ggnewscale)

gg.bad_clades <- bad_clades %>%
  filter(!paste0(threshold, pos_clade_id) %in% paste0(bad_clades_labels$threshold, bad_clades_labels$pos_clade_id)) %>%
  ggplot(aes(x= mean_depth_pos_clades/100, y=traits_per_pos_clades, colour=traits_per_pos_clades)) + 
  geom_jitter(aes(alpha=traits_per_pos_clades), height=.2, width=.002) + 
  scale_colour_viridis_c(option="C", trans="log10")+
  scale_alpha_continuous(trans="log10", range=c(0.2,1)) +
  new_scale_colour()+
  geom_point(data = bad_clades_labels, aes(x=mean_depth_pos_clades/100, y=traits_per_pos_clades),colour="firebrick", alpha=0.8)+
  geom_text_repel(data = bad_clades_labels, aes(x=mean_depth_pos_clades/100, y=traits_per_pos_clades, label= subtree_taxonomy, colour=order_taxonomy),
                  box.padding = .5)+
  scale_color_manual(values=order_pal) +
 #   facet_grid(~threshold) +
  scale_y_log10() +
  scale_x_continuous(labels = scales::percent_format(accuracy=1))+
  base_theme+
  theme(legend.position = "none",
        axis.text.x = element_text(angle=0)) + 
    labs(x="Phylogenetic depth of clade",
         y="Faied ID's per clade",
         fill = NULL,
         colour= "Taxonomic order")

gg.bad_clades

# Additional bad clades plot
library(tidytext)
gg.zscores <- bad_clades_labels %>%
  mutate(
    subtree_taxonomy = make.unique(subtree_taxonomy ),
    subtree_taxonomy  = factor(subtree_taxonomy ),
    subtree_taxonomy  = reorder_within(subtree_taxonomy, zscore, threshold)) %>%
  ggplot(aes(x = subtree_taxonomy, y = traits_per_pos_clades , fill=order_taxonomy))+
  geom_col()+
  #geom_text(aes(label= subtree_taxonomy), angle=90)+
  scale_color_manual(values=order_pal) +
  facet_grid(~threshold, drop=TRUE, scales="free_x") +
  scale_x_reordered()+
  base_theme +
  theme(legend.position = "right")
  
gg.zscores

# Phylo
# Prune tree to genus
tips_to_keep <- tree$tip.label %>% 
  enframe() %>% 
  tidyr::separate(value, into=c("acc", "Species"), sep="\\|") %>%
  left_join(lineage, by="acc")%>%
  mutate(tips = paste0(acc,"|", Species))  %>%
  left_join(folmer_id_spp %>% filter(threshold==0.97)) %>%
  filter(!is.na(Genus)) %>%
  group_by(Genus, Order) %>%
  summarise(values = sum(values), tips=sample(tips, 1), total_tips = n()) %>%
  ungroup() %>%
  mutate(values = replace_na(values, 0))


#Prune tree to genus
genus_tree  <- castor::get_subtree_with_tips(tree,
                                          only_tips = tips_to_keep$tips,
                                          collapse_monofurcations=TRUE,
                                          force_keep_root=TRUE)$subtree

genus_tree$tip.label <- genus_tree$tip.label %>%
  str_remove("\\|.*$")%>%
  enframe() %>%
  mutate(acc = value)%>%
  left_join(lineage) %>%
  pull(Genus)

Ntips 	<- length(genus_tree$tip.label)
Nnodes 	<- genus_tree$Nnode
cat(sprintf("Tree has %d nodes, %d tips and %d edges\n",Nnodes,Ntips,nrow(genus_tree$edge)));

# create internal node labels
genus_tree$node.label <- NA
if(is.na(genus_tree$node.label)){
	cat(sprintf("Adding node labels to full tree..\n"))
	genus_tree$node.label = paste("node.", 1:Nnodes, sep = "") # don't use underscores, because some tree readers (e.g. rncl) interpret them as spaces
}

# replace zero-length edges
if(any(genus_tree$edge.length==0)){
  epsilon = 0.1*min(genus_tree$edge.length[genus_tree$edge.length>0])
	cat(sprintf("Note: Some edges have length zero, which may break some of the HSP routines. Replacing zero-lengths with a tiny positive length (%g)..\n",epsilon))
	genus_tree$edge.length[genus_tree$edge.length==0] = epsilon
}

# Plot tree
p1 <- ggtree(genus_tree , ladderize=TRUE, aes(colour=values), layout = "circular") 

weights <- tips_to_keep %>%
  mutate(prop_pos = values / total_tips) %>%
  mutate(values = case_when(
    prop_pos > .5 ~ 1,
    prop_pos < .5 ~ 0
  ))

tip_states_binary <- weights %>%
    dplyr::pull(values)
names(tip_states_binary) <- weights %>%
    dplyr::pull(tips)
  
# Trait depth
consentrait <- get_trait_depth(genus_tree, tip_states_binary,
                                 min_fraction = 0.5, #90% of clade must be insufficiently ID'd to be problmeatic
                                 count_singletons=FALSE, weighted=TRUE, Npermutations = 1000)
  
pos_clades <- consentrait$positive_clades
trait_highlight <-  data.frame(
    pos_clade_id = pos_clades,
    traits_per_pos_clades = consentrait$positives_per_clade[pos_clades],
    mean_depth_pos_clades = consentrait$mean_depth_per_clade[pos_clades]
  )
  
# get weights from failed ID's
weights_p1 <- p1$data %>%
  left_join(trait_highlight %>%
              dplyr::select(node = pos_clade_id, values_higher = traits_per_pos_clades )) %>%
  left_join(weights %>%
              dplyr::select(label = Genus, values_genus = values)) %>%
  ungroup()%>%
  group_by(node)%>%
  mutate(values = sum(values_higher, values_genus, na.rm = TRUE)) %>%
  ungroup()

tip_states <- weights_p1 %>%
  dplyr::filter(isTip) %>%
  pull(values)
names(tip_states) <- weights_p1 %>%
  dplyr::filter(isTip) %>%
  pull(label)

weights_p1$values[!weights_p1$isTip] <- castor::asr_independent_contrasts(tree=genus_tree,
                                                          tip_states=tip_states, check_input = FALSE)$ancestral_states

# Could label it as positive clades instead?

p2 <- p1 %<+% weights_p1 +
 scale_color_gradient(low="darkslateblue", high="firebrick",na.value = NA, limits = c(0,1), oob = scales::squish) +
 theme(legend.position = "none") + 
 scale_y_continuous(expand=c(0,0))+ 
 scale_x_discrete(expand=c(0,0)) 

### make a clade label list
tax_groups <- tips_to_keep %>%
 dplyr::rename(label = Genus) %>%
 select(label, Order) %>%
 filter(label %in% genus_tree$tip.label) %>%
 group_by(Order) 

group_name <- group_keys(tax_groups)  %>%
 mutate(group_name = Order %>% str_remove_all("\\[|\\]"))

cls <- tax_groups %>% 
 group_split() %>% 
 purrr::map(pull, label) %>%
 set_names(group_name$group_name) %>%
 purrr::map(function(x){
   query <- x
   labs <-  p2$data %>%
     dplyr::filter(label %in% query)
   quants <- labs  %>% 
     dplyr::filter(between(y, left=quantile(labs$y,  probs =0.1), right=quantile(labs$y,  probs =0.90)))
   
   if(length(quants$label) > 1){
     mrca_node <- get_mrca_of_set(genus_tree, quants$label)
   
     if(mrca_node > Ntips){
       subset_node <- mrca_node-Ntips
     } else{
       subset_node <- mrca_node
     }
     subset_tree <- get_subtree_at_node(genus_tree, subset_node)$subtree
     print(length(subset_tree$tip.label))
     
     # Only label the bigger ones
     if(length(subset_tree$tip.label) < 50){
       mrca_node <- NULL
     }
   } else{
     mrca_node <- NULL
   }
   
   return(mrca_node)
 })

#drop small nodes
cls <- cls[!sapply(cls, is.null)]

p3 <- p2
for(l in 1:length(cls)){
 p3 <- p3 + geom_cladelabel(
   node=cls[[l]], label=names(cls[l]), 
   align=TRUE, hjust='left', offset.text=.25, angle="auto",
   barsize=1.5, color = order_pal[names(cls[l])])
}

fig4a <- gg.bad_clades / gg.failed  + plot_layout(heights=c(2,1))

fig4 <- p3 - fig4a + plot_layout(widths=c(3,1.5)) + plot_annotation(tag_levels = "A")

fig4
#Save figure 4
pdf(file="fig/Fig4_phylo_id.pdf", width = 11, height = 8 , paper="a4r")
  plot(fig4)
try(dev.off(), silent=TRUE)

```


# Predicted mismatch

```{r Primerminer, message=FALSE}
library(PrimerMiner)
## Target sequences to test against
seqs <- insect::readFASTA("reference/merged_final.fa.gz")
names(seqs) <- names(seqs) %>% str_replace_all(" ", "_")
writeFASTA(seqs, "primer_evaluation/merged_final_target.fa")

target <- "primer_evaluation/merged_final_target.fa"

# Load primers
primers <- read_csv("primer_evaluation/primer_candidates.csv") %>%
  mutate(seq = str_replace_all(seq, "I","N")) %>% 
  select(-score, -issues)

dir.create("primer_evaluation/PrimerMiner")

for (i in 1:nrow(primers)) {
  if(primers$strand[i]=="F"){
  evaluate_primer(target,
   as.character(primers$seq[i]), primers$start[i], primers$end[i],
   forward = TRUE, gap_NA = TRUE, N_NA=TRUE,
   mm_position = "Position_v1", mm_type = "Type_v1", adjacent = 2,
   save = paste0("primer_evaluation/PrimerMiner/", primers$name[i],".csv")
  )
  } else if(primers$strand[i]=="R"){
  evaluate_primer(target,
   as.character(primers$seq[i]), primers$start[i], primers$end[i],
   forward = FALSE, gap_NA = TRUE, N_NA=TRUE,
   mm_position = "Position_v1", mm_type = "Type_v1", adjacent = 2,
   save = paste0("primer_evaluation/PrimerMiner/", primers$name[i],".csv")
  )
 }
}

# gZip files
fs::dir_ls(path="primer_evaluation/PrimerMiner", glob = "*.csv") %>%
  purrr::map(R.utils::gzip)

```

# Fig 5 - Mismatch

```{r figure 4}
# Load primers
primers <- read_csv("primer_evaluation/primer_candidates.csv") %>%
  mutate(seq = str_replace_all(seq, "I","N")) %>% 
  dplyr::select(-any_of(c("score", "issues"))) %>%
  distinct()

#Read in all files

dat <- fs::dir_ls(path="primer_evaluation/PrimerMiner", glob = "*.csv|*.csv.gz") %>%
  purrr::set_names() %>%
  map_dfr(vroom::vroom, col_select= list("Template", "sequ", "sum"),
          .id = "source", progress=FALSE) %>%
  mutate(Template = str_remove(Template, ";$"))%>%
  separate(col=Template, into=c("Acc","Kingdom","Phylum","Class","Order","Family","Genus","Species"), sep=";") %>%
  dplyr::rename(Sequence = sequ) %>% 
  dplyr::mutate(primer = source %>% 
                  basename() %>%
                  str_remove(".csv") %>%
                  str_remove(".gz$")) %>%
  dplyr::select(primer,Acc, Genus, species, sum)

#vroom::vroom_write(dat, "primer_evaluation/mismatch_all.csv.gz",delim = ",")

genus_summaries <- vroom::vroom("primer_evaluation/mismatch_all.csv.gz", delim = ",") %>%
  tidyr::separate(Acc, into=c("Acc", "tax_id"), sep="\\|") %>%
  group_by(primer, Genus, tax_id) %>% #Group by higher to minimize plotting
  summarise(sum = mean(sum, na.rm=TRUE)) %>%
  ungroup()%>%
  mutate(dup = paste0(primer, Genus)) %>% 
  filter(!duplicated(dup)) %>% #remove any duplicates
  dplyr::select(-dup) %>%
  left_join(primers %>%
            dplyr::select(primer = name, strand))

#vroom::vroom_write(genus_summaries, "primer_evaluation/mismatch_summary.csv.gz",delim = ",")

genus_summaries <- vroom::vroom("primer_evaluation/mismatch_summary.csv.gz",delim = ",")

# Arrange on tree
tree <- ape::read.tree("reference/trees/ultrametric_insecta_tree_order_constrained.nwk")

# Filter summaries to just those in tree
genus_summaries <- genus_summaries %>% 
  dplyr::filter(Genus %in% (tree$tip.label %>% 
  str_remove("^.*\\|") %>%
  str_extract("^.+?(?=_)") %>%
    unique()))

# get Lineage
seqs <- insect::readFASTA("reference/merged_final.fa.gz")

seqs <- acc2hex(seqs)

lineage <- names(seqs) %>%
  str_split_fixed(pattern="\\|", n = 2) %>%
  as_tibble() %>%
  separate(V2, into=c("taxid","Kingdom", "Phylum", 
    "Class", "Order", "Family", "Genus", "Species"), sep=";") %>%
  dplyr::rename(acc = V1)%>%
  mutate(Species = Species %>% str_replace_all(" ", "_")) %>%
  dplyr::select(-Species)

# Prune tree to genus
tips_to_keep <- tree$tip.label %>% 
  enframe() %>% 
  tidyr::separate(value, into=c("acc", "Species"), sep="\\|") %>%
  left_join(lineage, by="acc") %>%
  filter(Genus %in% (genus_summaries %>% pull(Genus))) %>%
  group_by(Genus) %>%
  dplyr::slice(1) %>%
  ungroup() %>%
  mutate(tips = paste0(acc,"|", Species))


#Get subtree of only genera
genus_tree  <- castor::get_subtree_with_tips(tree,
                                          only_tips = tips_to_keep$tips,
                                          collapse_monofurcations=TRUE,
                                          force_keep_root=TRUE)$subtree

#Prune names to genus
genus_tree$tip.label <- genus_tree$tip.label %>% 
  str_remove("^.*\\|") %>%
  str_extract("^.+?(?=_)")

#Prune again to ensure matching tips
genus_tree <- castor::get_subtree_with_tips(genus_tree,
                                          only_tips = genus_tree$tip.label[genus_tree$tip.label %in% genus_summaries$Genus],
                                          collapse_monofurcations=TRUE,
                                          force_keep_root=TRUE)$subtree

Ntips 	<- length(genus_tree$tip.label)
Nnodes 	<- genus_tree$Nnode
cat(sprintf("Tree has %d nodes, %d tips and %d edges\n",Nnodes,Ntips,nrow(genus_tree$edge)));

# create internal node labels
genus_tree$node.label <- NA
if(is.na(genus_tree$node.label)){
	cat(sprintf("Adding node labels to full tree..\n"))
	genus_tree$node.label = paste("node.", 1:Nnodes, sep = "") # don't use underscores, because some tree readers (e.g. rncl) interpret them as spaces
}

# replace zero-length edges
if(any(genus_tree$edge.length==0)){
  epsilon = 0.1*min(genus_tree$edge.length[genus_tree$edge.length>0])
	cat(sprintf("Note: Some edges have length zero, which may break some of the HSP routines. Replacing zero-lengths with a tiny positive length (%g)..\n",epsilon))
	genus_tree$edge.length[genus_tree$edge.length==0] = epsilon
}


## Get values for higher nodes with castor
uprimers <- unique(genus_summaries$primer)
p_weights <- vector("list", length=length(uprimers))
names(p_weights) <- uprimers

for (i in 1:length(uprimers)){
  print(paste0("Processing Primer ",i, " of ", length(uprimers), ": ", uprimers[i]))
  tip_states <- genus_summaries %>%
    dplyr::filter(primer==uprimers[i], Genus %in% tips_to_keep$Genus) %>%
    #group_by(Genus) %>%
    #summarise(values = mean(sum, na.rm=TRUE))%>%
    #ungroup() %>%
    dplyr::rename(values = sum) %>%
    column_to_rownames("Genus")
    
  row2tip <- match(rownames(tip_states), genus_tree$tip.label)
  
  #find non matching
  rownames(tip_states)[is.na(row2tip)]
  
  tip_states <- tip_states[!is.na(row2tip),,drop = FALSE]
  hsp_states <- castor::hsp_independent_contrasts(tree = genus_tree,
                                              tip_states = tip_states$values,
                                              weighted = FALSE,
                                              check_input = TRUE)$states
  
  # Get distance of each tip to tips that have data
  target_tips <- match(tip_states %>% filter(!is.na(values)) %>% rownames(), genus_tree$tip.label);
  tip_dist <- castor::find_nearest_tips(genus_tree, only_descending_tips=FALSE, 
                                        target_tips=target_tips, as_edge_counts=FALSE, check_input=TRUE)
  
   p_weights[[i]] <- tip_states %>%
    rownames_to_column("Genus") %>%
    mutate(hsp = hsp_states[1:Ntips],
           tip_dist =tip_dist$nearest_distance_per_tip[1:Ntips])
}

imputed <- genus_summaries %>%
    left_join(bind_rows(p_weights,.id = "primer"), 
               by = c("primer", "Genus", "tax_id", "strand")) %>%
  select(-strand) %>%
  left_join(primers %>%
            dplyr::select(primer = name, degeneracy, strand))%>%
  filter(!is.na(hsp))

primer_orders <- imputed %>%
  group_by(primer) %>%
  dplyr::summarise(hsp = mean(hsp, na.rm=TRUE), sum = mean(sum, na.rm=TRUE)) %>%
  arrange(hsp)

# Plot tree
p1 <- ggtree(genus_tree , ladderize=TRUE, aes(colour=values))

weights_p1 <- p1$data %>%
  left_join(imputed %>%
              group_by(Genus) %>%
              summarise(values = mean(sum, na.rm=TRUE))%>%
              dplyr::rename(label = Genus)
    )  


tip_states <- weights_p1 %>%
  dplyr::filter(isTip) %>%
  pull(values)
names(tip_states) <- weights_p1 %>%
  dplyr::filter(isTip) %>%
  pull(label)

weights_p1$values[!weights_p1$isTip] <- castor::asr_independent_contrasts(tree=genus_tree,
                                                        tip_states=tip_states)$ancestral_states

p2 <- p1 %<+% weights_p1 +
  #geom_tippoint(aes(colour=values)) +
  scale_color_gradient(low="darkslateblue", high="firebrick") +
  theme(legend.position = "none") + 
  scale_y_continuous(expand=c(0,0))+ 
  scale_x_discrete(expand=c(0,0)) 

## make a clade label list
tax_groups <- tips_to_keep %>%
  dplyr::rename(label = Genus) %>%
  select(label, Order) %>%
  filter(label %in% genus_tree$tip.label) %>%
  group_by(Order) 

group_name <- group_keys(tax_groups)  %>%
  mutate(group_name = Order %>% str_remove_all("\\[|\\]"))

cls <- tax_groups %>% 
  group_split() %>% 
  purrr::map(pull, label) %>%
  set_names(group_name$group_name) %>%
  purrr::map(function(x){
    query <- x
    labs <-  p2$data %>%
      dplyr::filter(label %in% query)
    quants <- labs  %>% 
      dplyr::filter(between(y, left=quantile(labs$y,  probs =0.1), right=quantile(labs$y,  probs =0.90)))
    mrca_node <- get_mrca_of_set(genus_tree, quants$label)
    
    if(mrca_node > Ntips){
      subset_node <- mrca_node-Ntips
    } else{
      subset_node <- mrca_node
    }
    subset_tree <- get_subtree_at_node(genus_tree, subset_node)$subtree
    print(length(subset_tree$tip.label))
    
    # Only label the bigger ones
    if(length(subset_tree$tip.label) < 1000){
      mrca_node <- NULL
    }
    
    return(mrca_node)
  })

#drop small nodes
cls <- cls[!sapply(cls, is.null)]

# colours 
colourCount = length(cls)
getPalette = colorRampPalette(brewer.pal(12, "Paired"))
colour.pal <- getPalette(colourCount)

p3 <- p2
for(i in 1:length(cls)){
p3 <- p3 + geom_cladelabel(node=cls[[i]], label=names(cls[i]), align=T, angle=270, hjust='center', offset.text=.5, barsize=1.5, color = colour.pal[[i]])
}

p3

# Plot heatmap
gg.mismatch <- imputed %>%
  left_join(p2$data %>% dplyr::select(label, y) %>% dplyr::rename(Genus = label)) %>%
  mutate( primer = factor(primer, levels=primer_orders$primer)) %>%     
  ggplot(aes(x = primer, y = y, fill = hsp)) +
    geom_raster() +
  #scale_fill_distiller(palette = 'RdYlBu', limits = c(0, 200), oob = scales::squish)+
    scale_fill_gradient(low = "darkslateblue", high = "firebrick", na.value = "grey", limits = c(0, 200), oob = scales::squish) +
    facet_grid(~strand, scales="free", space="free", drop=TRUE) +
    #theme_classic() + 
    theme(
      axis.text.x = element_blank(),
      axis.ticks = element_blank(),
      axis.text.y = element_blank(),
      axis.title = element_blank(),
      strip.text.y = element_text(angle = 0),
      #strip.background = element_rect(fill="grey10"),
      legend.position = "none"
    ) + 
  scale_y_continuous(expand=c(0,0))+ 
  scale_x_discrete(expand=c(0,0))

# Density plot of mismatch
zscore_labels <- imputed %>%
  left_join(p2$data %>% dplyr::select(label, y) %>% dplyr::rename(Genus = label)) %>%
  group_by(Genus, y) %>%
  summarise(values = mean(sum, na.rm=TRUE)) %>%
  ungroup() %>%
  left_join(lineage %>% select(Genus, Family, Order) %>% distinct())%>%
  arrange(y) 
  
chunk = 1000
n <- nrow(zscore_labels)
r  <- rep(1:ceiling(n/chunk),each=chunk)[1:n]
zscore_labels_chunked <- split(zscore_labels,r)

zscore_labels <- zscore_labels_chunked %>% 
  purrr::map(function(x){
    df <- x %>%
      mutate(zscore = (values - mean(values, na.rm=TRUE))/sd(values, na.rm=TRUE)) %>%
      filter(zscore  > 3, values  >200) 
    if(nrow(df) > 0){
        out <- df %>%
        summarise(y = mean(y), values = max(values), annot =  case_when(
        length(unique(Genus)) == 1 ~ names(which.max(table(Genus))),
        length(unique(Genus)) > 1~  names(which.max(table(Family)))
        ))
        return(out)
    }
    
  }) %>%
  bind_rows() %>%
  filter(!is.na(annot))

    
gg.density <- imputed %>%
  left_join(p2$data %>% dplyr::select(label, y) %>% dplyr::rename(Genus = label)) %>%
  group_by(Genus, y) %>%
  summarise(values = mean(sum, na.rm=TRUE)) %>%
  ggplot(aes(x = y, y=values, fill=values, colour=values)) +
  geom_point(size=0.01, alpha=0.5)+
  geom_text(data=zscore_labels, aes(label = annot), hjust=0) +
  #geom_smooth(span = 0.1)+
  scale_colour_gradient(low="darkslateblue", high="firebrick") + 
  scale_x_continuous(expand=c(0,0)) +
  scale_y_continuous(expand=c(0,0)) +
  theme_void() +
  theme(legend.position = "none")+
  coord_flip()

# plot tip dist (missing data), mean mismatch, evenness of mismatch, and degeneracy

gg.primer_stats <- imputed %>%
   mutate(primer = factor(primer, levels=primer_orders$primer)) %>%     
  group_by(primer, strand) %>%
  summarise(
    tip_dist = mean(tip_dist),
    mean_mismatch = mean(hsp, na.rm=TRUE),
    degeneracy = log2(mean(degeneracy)),
    #degeneracy = mean(degeneracy)
    ) %>%
  pivot_longer(3:5, 
               names_to="measure",
               values_to="value") %>%
  mutate(measure = factor(measure, levels = c("mean_mismatch", "degeneracy", "tip_dist"))) %>%
  group_by(measure) %>%
  mutate(cols = value) %>%
  mutate_at(c("cols"),  ~ . / max(.) ) %>%
  ggplot(aes(x = primer, y = value, fill=cols)) +
    geom_col() +
    scale_fill_gradient(low = "darkslateblue", high = "firebrick", na.value = "grey",  oob = scales::squish, trans=scales::pseudo_log_trans(10)) +
    facet_grid(measure~strand, scales="free", switch="y", drop=TRUE) +
  base_theme+
    theme(
      axis.title.y = element_blank(),
      #axis.text.y = element_blank(),
      #axis.ticks.y = element_blank(),
      axis.text.x = element_text(size=7, angle=0),
      axis.ticks = element_line(colour = "grey20"),
      #panel.grid.minor.y = element_blank(),
      panel.grid.minor.x = element_blank(),
      panel.grid.major.x = element_blank(),
      strip.text.x = element_blank(),
      strip.text.y = element_text(angle=0),
      legend.position = "none"
    ) + 
  scale_y_continuous(expand=c(0,0), position="right")+ 
  scale_x_discrete(expand=c(0,0), guide = guide_axis(n.dodge = 1, angle=90))

Fig5a <- (p3 + scale_x_continuous(expand=c(0,0))) + gg.mismatch + gg.density + plot_layout(widths = c(1,4,0.25))
Fig5b <- plot_spacer() + gg.primer_stats + plot_spacer() + plot_layout(widths = c(1,4.7,0.025))

Fig5 <- Fig5a / Fig5b + plot_layout(heights = c(7, 1))

#Fig5
pdf(file="fig/Fig5_mismatch.pdf", width = 8, height = 11 , paper="a4")
  plot(Fig5)
try(dev.off(), silent=TRUE)
 
## Supplementary plot of unimputed mismatch

# Plot heatmap
gg.mismatch_un <- imputed %>%
  left_join(p2$data %>% dplyr::select(label, y) %>% dplyr::rename(Genus = label)) %>%
  mutate( primer = factor(primer, levels=primer_orders$primer)) %>%     
  ggplot(aes(x = primer, y = y, fill = sum)) +
    geom_raster() +
  #scale_fill_distiller(palette = 'RdYlBu', limits = c(0, 200), oob = scales::squish)+
    scale_fill_gradient(low = "darkslateblue", high = "firebrick", na.value = "grey", limits = c(0, 200), oob = scales::squish) +
    facet_grid(~strand, scales="free", space="free", drop=TRUE) +
    #theme_classic() + 
    theme(
      axis.text.x = element_blank(),
      axis.ticks = element_blank(),
      axis.text.y = element_blank(),
      axis.title = element_blank(),
      strip.text.y = element_text(angle = 0),
      #strip.background = element_rect(fill="grey10"),
      legend.position = "none"
    ) + 
  scale_y_continuous(expand=c(0,0))+ 
  scale_x_discrete(expand=c(0,0))


# plot tip dist (missing data), mean mismatch, evenness of mismatch, and degeneracy

gg.primer_stats_un <- imputed %>%
   mutate(primer = factor(primer, levels=primer_orders$primer)) %>%     
  group_by(primer, strand) %>%
  summarise(
    tip_dist = mean(tip_dist),
    mean_mismatch = mean(hsp, na.rm=TRUE),
    degeneracy = log10(mean(degeneracy))
    ) %>%
  pivot_longer(3:5, 
               names_to="measure",
               values_to="value") %>%
  mutate(measure = factor(measure, levels = c("mean_mismatch", "degeneracy", "tip_dist"))) %>%
  group_by(measure) %>%
  mutate(cols = value) %>%
  mutate_at(c("cols"),  ~ . / max(.) ) %>%
  ggplot(aes(x = primer, y = value, fill=cols)) +
    geom_col() +
    scale_fill_gradient(low = "darkslateblue", high = "firebrick", na.value = "grey",  oob = scales::squish) +
    facet_grid(measure~strand, scales="free", switch="y", drop=TRUE) +
  base_theme+
    theme(
      axis.title.y = element_blank(),
      #axis.text.y = element_blank(),
      #axis.ticks.y = element_blank(),
      axis.text.x = element_text(size=7, angle=0),
      axis.ticks = element_line(colour = "grey20"),
      #panel.grid.minor.y = element_blank(),
      panel.grid.minor.x = element_blank(),
      panel.grid.major.x = element_blank(),
      strip.text.x = element_blank(),
      strip.text.y = element_text(angle=0),
      legend.position = "none"
    ) + 
  scale_y_continuous(expand=c(0,0), position="right")+ 
  scale_x_discrete(expand=c(0,0), guide = guide_axis(n.dodge = 1, angle=90))

sup3a <- p3 + gg.mismatch_un + gg.density + plot_layout(widths = c(1,4,0.25))
sup3b <- plot_spacer() + gg.primer_stats_un + plot_spacer() + plot_layout(widths = c(1,4.7,0.025))

sup3 <- sup3a / sup3b + plot_layout(heights = c(7, 1))

sup3
pdf(file="fig/supplementary/sup_mismatch.pdf", width = 8, height = 11 , paper="a4")
  plot(sup3)
try(dev.off(), silent=TRUE)
  

# Mismatch by primer degeneracy
  
model_df <- imputed %>% 
  select(primer, Unimputed = values, Imputed = hsp, degeneracy) %>%
  pivot_longer(cols=c("Unimputed", "Imputed"),
               names_to="type",
               values_to = "values")%>%
  drop_na() %>%
 # group_by(primer, type) %>%
  sample_n(100000)
  #summarise(values = mean(values), degeneracy = mean(degeneracy)) %>%
 # mutate(degeneracy = log10(degeneracy))
  

# Plot summary
model_df  %>%
  ggplot(aes(x = degeneracy, y= values))+
  geom_point(alpha=1) + 
  geom_smooth()+
  facet_grid(type~.) + 
  #scale_x_continuous(trans="log10")+
 # scale_x_continuous(trans=scales::pseudo_log_trans(200), breaks = c(0, 64, 256, 512, 1024, 2048, 5096, 10192)) +
  base_theme +
  theme(panel.grid.minor = element_blank())+
  labs(x = "Primer Degeneracy",
        y = "Mean Mismatch")

# Fit segmented regression

library(chngpt)
degen_fits <- model_df %>% 
  group_by(type) %>%
  nest() %>%
  mutate(fits = purrr::map(data, ~chngptm(formula.1=values~1, formula.2=~degeneracy,
                                   type="upperhinge", family="gaussian",data = .)),
         summary = purrr::map(fits, summary),
         #preds = map2(fits, data, predict),
         aug = purrr::map2(fits, data, function(x,y){
           preds <- predict(x,y)
           out <- y
           out$preds <- preds
           out$res <- NA
           out$res[!is.na(out$preds)] <- resid(x)
           return(out)
           }),
         breakpoint = purrr::map(fits, "chngpt"),
         breakpoint_ests = purrr::map(summary, function(x){ as.data.frame(t(x$chngpt))}),
         coef_info = purrr::map(summary,function(x){ as_tibble(x$coefficients, rownames="term" )})
         )


# Get SE of breakpoints
degen_fits %>% 
  unnest(breakpoint_ests) %>% 
 select(-where(is.list)) %>%
  dplyr::rename(upper = `upper)`, lower = `(lower`, std_error = `Std. Error`) %>%
  mutate(est = 10^est, lower = 10^lower, upper=10^upper, std_error = 10^std_error)

slope_coefs <- degen_fits %>%
  unnest(coef_info) %>%
  dplyr::select(type, term, est, std_err = `Std. Error*`,
                lower = `(lower`, upper = `upper)`,
                pval = `p.value*`, -where(is.list), type) %>%
  mutate(
    term = case_when(
    term == "(Intercept)" ~  "intercept",
    term == "amplicon" ~  "slope",
    term == "(amplicon-chngpt)+" ~ "post_slope"
    )) %>%
  mutate(signif = pval < 0.05) %>%
  mutate(expest = 10^est)


dat_pred <- degen_fits %>%
  unnest(aug, breakpoint)%>%
  select(-where(is.list))  %>%
  drop_na() %>%
  left_join(slope_coefs %>%
              select(type, term, signif, est) %>%
              pivot_wider(names_from=term, values_from=c(signif, est))) 


break_annot <- dat_pred %>% 
  group_by(type) %>%
  filter(degeneracy == breakpoint) %>%
  dplyr::slice(1) %>%
  left_join(slope_coefs %>%
              filter(term == "post_slope") %>%
              select( pval, signif))

gg.degen_breakpoint <- model_df %>%
  left_join(dat_pred) %>%
  ggplot(aes(x = 10^degeneracy, y= values))+
  geom_point(alpha=1) + 
  geom_line(data=dat_pred[dat_pred$degeneracy < dat_pred$breakpoint,],
             aes(x=10^degeneracy, y=preds),  color = 'red', inherit.aes = FALSE) +
  geom_line(data=dat_pred[dat_pred$degeneracy >= dat_pred$breakpoint,],
            aes(x=10^degeneracy, y=preds),  color = 'red', inherit.aes = FALSE) +
  geom_point(data=break_annot, aes(x=10^degeneracy, y=preds), size=2, color = 'red', inherit.aes = FALSE) +
   geom_text(data=break_annot, aes(x=10^degeneracy, y=preds,
                                  label=paste0(round(10^breakpoint,2), "bp")), #,ifelse(pval < 0.001,"<0.001", ">0.001")
            nudge_y =50,nudge_x = 0,  color = 'red', inherit.aes = FALSE) +
  #geom_smooth()+
  facet_grid(type~.) + 
  scale_x_continuous(trans="log10")+
 # scale_x_continuous(trans=scales::pseudo_log_trans(200), breaks = c(0, 64, 256, 512, 1024, 2048, 5096, 10192)) +
  base_theme +
theme(panel.grid.minor = element_blank(),
        legend.position = "bottom",
        strip.background = element_rect(colour = "black", fill = "lightgray"),
        strip.text = element_text(size=9, family = ""))+ 
  labs(x = "Primer degeneracy",
        y = "Mean Mismatch")


gg.degen_breakpoint

# Save
pdf(file="fig/supplementary/degen_breakpoint.pdf", width = 11, height = 8 , paper="a4r")
  plot(gg.degen_breakpoint)
try(dev.off(), silent=TRUE)

# Not significant, fit normal Regresison
degen_fits <- model_df %>%
  group_by(type) %>%
  nest() %>%
  mutate(fit = map(data, ~ lm(values ~ degeneracy, data = .x)),
    tidied = map(fit, broom::tidy),
    glanced = map(fit, broom::glance),
    augmented = map(fit, broom::augment)
         )

degen_fits %>%
  unnest(tidied)

degen_fits  %>% 
  select(glanced) %>% 
  unnest(glanced)
```

# ACF Mismatch

```{r autocrrelation}
tree <- ape::read.tree("reference/trees/ultrametric_insecta_tree_order_constrained.nwk")

primer_mismatch <- vroom::vroom("primer_evaluation/mismatch_all.csv.gz",delim = ",") %>% 
  mutate(Acc = Acc %>% str_remove("\\|.*$") %>%
           acc2hex()) %>%
  mutate(tips = paste0(Acc, "|", Species)) %>%
  select(primer, tips, values = sum)


uprimers <- unique(primer_mismatch$primer)
acfvec <- vector("list", length=length(uprimers))
names(acfvec) <- uprimers
traitvec <- vector("list", length = length(uprimers))
names(traitvec) <- uprimers

i=1
for (i in 1:length(uprimers)){
  weights <- tree$tip.label %>% 
      enframe() %>% 
      select(-name, tips = value) %>%
        left_join(primer_mismatch %>%
                    filter(primer == uprimers[i]))%>%
      filter(!is.na(values))


  # Subset to only those with known states
  subset_tree <- get_subtree_with_tips(tree, weights$tips)$subtree
        print(length(subset_tree$tip.label))
  message(length(subset_tree$tip.label), " tips with known states kept for ", uprimers[i])

  # Get tip states
  tip_states <- weights %>%
    dplyr::pull(values)
  names(tip_states) <- weights %>%
    dplyr::pull(tips)
  
  # Autocorrelation funciton
  acf <- castor::get_trait_acf(subset_tree, tip_states, Npairs=1e8, Nbins=100)
  
 # # Trait depth
 # tip_states_binary <- tip_states
 # tip_states_binary[tip_states_binary >0] <- 1
 # consentrait <- get_trait_depth(subset_tree, tip_states_binary,
 #                                min_fraction = 0.9, #90% of clade must be insufficiently ID'd to be problmeatic
 #                                count_singletons=TRUE, weighted=FALSE, Npermutations = 1000)
 # 
  # Create output data frame
  acfvec[[i]] <- data.frame(
    distances = acf$distances,
    acf_acf = acf$autocorrelations,
    acf_mean_abs = acf$mean_abs_differences,
    acf_mean_rel = acf$mean_rel_differences,
    acf_npairs = acf$Npairs_per_distance)
  
 #pos_clades <- consentrait$positive_clades
 #traitvec[[i]] <-  data.frame(
 #  pos_clade_id = pos_clades,
 #  traits_per_pos_clades = consentrait$positives_per_clade[pos_clades],
 #  mean_depth_pos_clades = consentrait$mean_depth_per_clade[pos_clades]
 #)
}

acf <- acfvec %>%
  bind_rows(.id="primer")

vroom::vroom_write(acf, "primer_evaluation/acf_mismatch.csv.gz",delim = ",")

consentrait <- traitvec %>%
  bind_rows(.id="primer")
vroom::vroom_write(consentrait, "primer_evaluation/consentrait_mismatch.csv.gz",delim = ",")


acf <- vroom::vroom("primer_evaluation/acf_mismatch.csv.gz") %>%
    filter(acf_npairs > 0)  %>%

# Load primers
primers <- read_csv("primer_evaluation/primer_candidates.csv") %>%
  mutate(seq = str_replace_all(seq, "I","N")) %>% 
  select(-score, -issues, primer= name) %>%
  distinct() %>%
  left_join(primer_mismatch %>%
  group_by(primer) %>%
  summarise(
    mean_mismatch = mean(values, na.rm=TRUE)
    )
  )

gg.facf <- acf %>%
  left_join(primers) %>%
  select(-acf_npairs) %>%
  group_by(primer) %>%
  pivot_longer(starts_with("acf_"),
               names_to="type",
               values_to="value") %>%
  ungroup() %>%
 filter(type == "acf_acf", strand=="F") %>%
  mutate(new_order = factor(primer, levels = unique(primer[order(mean_mismatch)]))) %>%
#  mutate(primer = fct_reorder(primer, mean_mismatch)) %>%
ggplot(aes(x = distances, y=value)) +
  geom_line(alpha=1, colour="black") +
  geom_text(data=primers %>%
              filter(strand=="F") %>%
              mutate(new_order = factor(primer, levels = unique(primer[order(mean_mismatch)]))), aes(label = paste0("MM:", round(mean_mismatch,1)), x=2, y=-0.6), inherit.aes = FALSE, colour="red", hjust=0, check_overlap = TRUE) +
  base_theme +
  facet_wrap(~new_order) +
  labs(y = "Pearson correlation",
       x = "Phylogenetic distance",
       title = "Forward primers")

gg.racf <- acf %>%
  left_join(primers) %>%
  select(-acf_npairs) %>%
  group_by(primer) %>%
  pivot_longer(starts_with("acf_"),
               names_to="type",
               values_to="value") %>%
  ungroup() %>%
 filter(type == "acf_acf", strand=="R") %>%
  mutate(new_order = factor(primer, levels = unique(primer[order(mean_mismatch)]))) %>%
#  mutate(primer = fct_reorder(primer, mean_mismatch)) %>%
ggplot(aes(x = distances, y=value)) +
  geom_line(alpha=1, colour="black") +
  geom_text(data=primers %>%
              filter(strand=="R") %>%
              mutate(new_order = factor(primer, levels = unique(primer[order(mean_mismatch)]))), aes(label = paste0("MM:", round(mean_mismatch,1)), x=2, y=-0.6), inherit.aes = FALSE, colour="red", hjust=0, check_overlap = TRUE) +
  base_theme +
  facet_wrap(~new_order) +
  labs(y = "Pearson correlation",
       x = "Phylogenetic distance",
       title = "Reverse primers")


gg.all_acf <- gg.facf + gg.racf

gg.all_acf

pdf(file="fig/supplementary/all_acf.pdf", width = 11, height = 8 , paper="a4r")
  plot(gg.all_acf)
try(dev.off(), silent=TRUE)
  
  
consentrait <- vroom::vroom("primer_evaluation/consentrait_mismatch.csv.gz") 

consentrait %>%
  left_join(primers %>% mutate(primer = name)) %>%
ggplot(aes(x = primer, y=mean_depth_pos_clades, size=traits_per_pos_clades )) +
  geom_point(alpha=0.2, colour="black") +
  facet_grid(strand~., drop = TRUE) +
  coord_flip()
  
```


# Fig 6 - Final Rankings 

```{r final }
# Primer stats
primers <- read_csv("primer_evaluation/primer_candidates.csv")

# Number of sequences
# Make plot
primer_stats <- primers %>%
      mutate(poly=pmax(poly_A,poly_T, poly_G, poly_C)) %>%
  dplyr::select(primer = name, strand, `GC%`, GC_clamp = GC_last2, tm, Degeneracy = degeneracy, Length = length, Longest_homopolymer = poly, nseqs = seqs) %>%
  #mutate(degeneracy = log10(degeneracy)) %>%
  pivot_longer(3:ncol(.),
               names_to = "metric",
               values_to ="value") %>%
    mutate(label = case_when(
    metric == "GC%" & between(value, 0.4, 0.6) ~ "good",
    metric == "GC%" & (between(value, 0.3, 0.4) |  between(value, 0.6, 0.7)) ~ "medium",
    metric == "GC%" & (between(value, 0, 0.3) |  between(value, 0.7, 0.1)) ~ "bad",
    
    metric == "Degeneracy" & between(value, 0, 517) ~ "good",
    metric == "Degeneracy" & between(value, 517, 1026) ~ "medium",
    metric == "Degeneracy" & value > 1026 ~ "bad",
    
    metric == "GC_clamp" & value == 2 ~ "good",
    metric == "GC_clamp" & value == 1 ~ "medium",
    metric == "GC_clamp" & value == 0 ~ "bad",
    
    metric == "Length" & between(value, 18, 24) ~ "good",
    metric == "Length" & (between(value, 16, 18) | between(value, 24, 26)) ~ "medium",
    metric == "Length" & (value < 16 | value > 26) ~ "bad",
    
    metric == "Longest_homopolymer" & value <= 3 ~ "good",
    metric == "Longest_homopolymer" & value <= 4 ~ "medium",
    metric == "Longest_homopolymer" & value > 4~ "bad",
    
    metric == "tm" & between(value, 48, 62) ~ "good",
    metric == "tm" & (between(value, 43, 48) | between(value, 62, 65)) ~ "medium",
    metric == "tm" & (value < 43 | value > 65) ~ "bad",
    
    metric == "nseqs" & value > 250000 ~ "good",
    metric == "nseqs" & between(value, 100000, 250000)  ~ "medium",
    metric == "nseqs" & value < 100000 ~ "bad",
  )) 

# Mismatch summary
mismatch_summary <-  vroom::vroom("primer_evaluation/mismatch_summary.csv.gz",delim = ",") %>%
  mutate(sum = replace_na(sum, 0),
         strand = replace_na(strand, "R")) %>%
  group_by(primer, strand) %>%
  summarise(mismatch = mean(sum, na.rm=TRUE), sd = sd(sum), se=sd(sum)/sqrt(length(sum)), upper = mismatch+(2*sd), lower =  mismatch-(2*sd)) %>%
  ungroup() %>%
  #mutate(upper = mismatch + se, lower  = mismatch - se) %>%
  #mutate(upper = mismatch + se, lower  = mismatch - se) %>%
  mutate(lower = case_when(
    lower >= 0 ~ lower,
    lower < 0 | is.na(lower)  ~ 0
  )) %>%
  mutate(label = case_when(
    mismatch < 20 ~ "good",
    between(mismatch, 20, 100) ~ "medium",
    mismatch > 100 ~ "bad"
  ))


# Id success res
id_success_summary <- vroom::vroom("primer_evaluation/residuals_summary.csv", delim=",") %>%
  pivot_longer(contains("name"),
               names_to="strand",
               values_to="primer") %>%
  mutate(strand = strand %>% str_remove("name")) %>%
  select(primer, strand, threshold, res, type)%>%
  filter(threshold  >= 0.97) %>%
  distinct() %>%
  ungroup() %>%
  group_by(primer, strand, type) %>%
  summarise(mean_res = mean(res),sd = sd(res), se=sd(res)/sqrt(length(res)), upper = mean_res+(2*sd), lower =  mean_res-(2*sd)) %>%
  ungroup() %>%
 # mutate(upper = mean_res + se, lower = mean_res - se) %>%
  mutate(label = case_when(
    mean_res > 0.015~ "good",
    between(mean_res, -0.015, 0.015) ~ "medium",
    mean_res < 0.015 ~ "bad"
  ))

# Z normalise each metric & rank
scale_this <- function(x){
  (x - mean(x, na.rm=TRUE)) / sd(x, na.rm=TRUE)
}

ranks <- primer_stats %>%
  filter(!metric == "nseqs") %>%
  mutate(count = case_when(
    label == "good" ~ 2,
    label == "medium" ~ 1,
    label == "bad" ~ 0
  ))%>%
  group_by(strand, metric) %>%
  mutate(count = scale_this(count)) %>% 
  ungroup() %>%
  #summarise(count = sum(count))%>%
  #ungroup() %>%
  #select(primer, strand, count)%>%
  #mutate(count = as.vector(scale(count))) %>%
    dplyr::rename(type=metric) %>%
  bind_rows(
  id_success_summary %>%
    filter(type =="All Insects") %>%
    select(primer, strand, count = mean_res)%>%
    mutate(count = scale_this(count)) %>%
    mutate(type="id_all")) %>%
  bind_rows(
  id_success_summary %>%
    filter(type =="Pest Insects") %>%
    select(primer, strand, count = mean_res)%>%
    mutate(count = scale_this(count)) %>%
    mutate(type="id_pest")) %>%
  bind_rows(mismatch_summary %>%
    select(primer, strand, count = mismatch)%>%
    mutate(count = scale_this(1-count)) %>% 
    mutate(type="mismatch")) %>%
  mutate(weights = case_when(
   type %in% c("GC%", "GC_clamp", "tm", "Degeneracy", "Length","Longest_homopolymer") ~ 0.25,
   type  %in% c("id_all", "id_pest") ~ 0.5,
   type %in% c("mismatch") ~ 1
  ))%>%
  mutate(count = count * weights) %>%
  ungroup() %>%
  group_by(primer, strand) %>%
  summarise(count = sum(count)) %>%
  ungroup() %>%
  group_by(strand)%>%
  arrange(desc(count),.by_group	=TRUE) %>%
  mutate(rank = 1:n())

# ID success from all primer combinations

gg.primer_stats <-primer_stats %>%
  mutate(facet = case_when(
    metric == "nseqs" ~ "N seqs",
    TRUE ~ "Primer Characteristics"
  ),
  facet = factor(facet, levels = c("Primer Characteristics", "N seqs"))) %>%
  mutate(value = case_when(
    metric=="GC%" ~ paste0(round(value*100, 1)),
    metric=="nseqs" ~ paste0(round(value/1000,0), "K"),
    #metric=="length" ~ paste0(value, "bp"),
    #metric=="GC_last2" ~ paste0(value, "bp"),
    #metric=="poly" ~ paste0(value, "bp"),
    #metric=="tm" ~ paste0(round(value,1), "°C"),
    TRUE ~ as.character(round(value,1))
  ))%>%
  #filter(!metric == "nseqs") %>%
  mutate(metric = factor(metric, levels = c("nseqs", "Degeneracy","Length", "tm", "GC%", "GC_clamp", "Longest_homopolymer"))) %>%
  left_join(ranks)%>%
  mutate(primer = factor(primer)) %>%
  ggplot(aes(x = fct_reorder(primer, -rank), y = metric, fill=label)) + 
  geom_tile(alpha=0.8) +
  geom_text(aes(label=value), colour="grey30") +
  facet_grid(strand~facet, drop = TRUE, scales = "free", space="free") +
  base_theme + 
  scale_fill_manual(values = c(bad ="#f86652", medium="khaki", good="#4595ce")) +
  coord_flip() +
  theme(axis.text.y=element_blank(),
        axis.title.y = element_blank(),
        panel.grid = element_blank(),
        axis.ticks.y = element_blank(),
        strip.background = element_rect(colour = "black", fill = "lightgray"),
        strip.text = element_text(size=9, family = "")) +
  scale_x_discrete(expand=c(0,0))+
  scale_y_discrete(expand=c(0,0))

gg.mean_mismatch <- mismatch_summary %>% 
    left_join(ranks)%>%
  mutate(facet = "Mismatch") %>%
  mutate(primer = factor(primer)) %>%
  ggplot(aes(x = fct_reorder(primer, -rank), y = mismatch)) +
  geom_pointrange(aes(ymin=lower, ymax = upper, fill=mismatch),shape=21, colour="grey30") +
  facet_grid(strand~facet, drop = TRUE, scales = "free") +
  base_theme + 
  #scale_colour_manual(values = c(bad ="#f86652", medium="khaki", good="#4595ce")) +
  #scale_colour_gradient(high ="#fc8d59", low="#4595ce", trans="log10") +
  scale_fill_distiller(palette = "RdYlBu", direction = -1, trans="log10")+
  coord_flip() +
  scale_y_continuous(trans="log10")+
  theme(strip.text.y = element_blank(),
        strip.background.y = element_blank(),
        strip.background.x = element_rect(colour = "black", fill = "lightgray"),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank(),
        panel.grid.major.y =  element_blank(),
        panel.grid.minor.y = element_blank(),
        panel.grid.minor.x = element_blank()
        ) +
  labs(x = NULL, y = "Mean Mismatch")

gg.primer_success <- id_success_summary  %>%
    left_join(ranks)%>%
 #   left_join(primers %>% select(primer=name, citation)) %>%
 # mutate(primer = factor(paste0(primer, "(",citation,")"))) %>%
  ggplot(aes(x = fct_reorder(primer, -rank), y = mean_res, fill=mean_res)) +
  geom_hline(yintercept = 0, colour="grey30")+
  geom_pointrange(aes(ymin=lower, ymax = upper),shape=21, colour="grey30") +
  #geom_boxplot(outlier.alpha = 0.1) +
  #scale_y_log10()+
  facet_grid(strand~type, drop = TRUE, scales = "free_y") +
  base_theme + 
  #scale_colour_manual(values = c(bad ="#fc8d59", medium="khaki", good="#91bfdb")) +
  #scale_colour_gradient2(low ="firebrick", mid="grey60", high="#4595ce",midpoint = 0, limits=c(-0.025, 0.025), breaks=c(-0.025,0,0.025), oob=scales::squish) +
  #scale_colour_viridis_c()+
  scale_y_continuous(labels = scales::percent_format(accuracy = 1), breaks=c(-0.1, -0.05,0,0.05,0.1))+
  coord_flip() +
  scale_fill_distiller(palette = "RdYlBu", direction = +1)+
  theme(strip.text.y = element_blank(),
        strip.background.y = element_blank(),
        strip.background.x = element_rect(colour = "black", fill = "lightgray"),
        legend.position = "none",
        panel.grid.major.y =  element_blank(),
        panel.grid.minor.y = element_blank(),
        panel.grid.minor.x = element_blank()) +
  labs(y = "Successfully Identified",
       x = "Primer")

# Plotting
Fig6 <- gg.primer_success + gg.mean_mismatch + gg.primer_stats + 
  plot_layout(widths =c(2,1, 4.5)) & theme(plot.margin = unit(c(0.25,0.25,0.25,0.25), "mm"), panel.spacing = unit(0.25, "lines"))


Fig6

pdf(file="fig/Fig6_final_summary.pdf", width = 8, height = 11 , paper="a4")
  plot(Fig6)
try(dev.off(), silent=TRUE)
```

