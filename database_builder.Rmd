---
title: "Database builder"
output: html_notebook
editor_options: 
  chunk_output_type: console
---

# Setup & Packages 

```{r setup}
# Knitr global setup - change eval to true to run code
library(knitr)
knitr::opts_chunk$set(echo = TRUE, eval=FALSE, message=FALSE,error=FALSE,fig.show = "hold", fig.keep = "all")

#Set required packages
.cran_packages <- c("usethis",
                    "tidyverse",
                    "rentrez", 
                    "bold",
                    "insect",
                    "ape",
                    "RColorBrewer",
                    "seqinr",
                    "patchwork",
                    "ShortRead",
                    "patchwork",
                    "geiger",
                    "castor",
                    "phytools")

.bioc_packages <- c("DECIPHER",
                    "ggtree",
                    "Biostrings")

.inst <- .cran_packages %in% installed.packages()
if(any(!.inst)) {
   install.packages(.cran_packages[!.inst])
}
.inst <- .bioc_packages %in% installed.packages()
if(any(!.inst)) {
  if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")
  BiocManager::install(.bioc_packages[!.inst], ask = F)
}

#Load all packages
sapply(c(.cran_packages,.bioc_packages), require, character.only = TRUE)

# Github packages
devtools::install_github("alexpiper/taxreturn")
library(taxreturn)

# SOurce internal functions
source("R/helper_functions.R")
source("R/themes.R")


## Get an NCBI api key for taxize queries
# use_entrez()

# After generating your key set it as ENTREZ_KEY in .Renviron.
# ENTREZ_KEY='1c0a0c4afa28448650a1450662a22c68f208'
#usethis::edit_r_environ()
```

## Download data for all insecta

```{r retrieve sequences, eval=FALSE, include=FALSE}
dir.create("reference/insecta/genbank",  recursive = TRUE)
dir.create("reference/insecta/bold",  recursive = TRUE)

## Fetch sequences from GenBank
genbank <- fetchSeqs("Insecta", database = "genbank", out.dir="reference/insecta/genbank", downstream = "Order", quiet=FALSE, marker="COI OR COI OR COX1 OR COXI", output = "gb-binom", compress=TRUE, multithread=TRUE, force=TRUE)

## Fetch sequences from BOLD
bold <- fetchSeqs("Insecta", database="bold", out.dir="reference/insecta/bold", downstream = "Family", quiet=FALSE, marker="COI-5P", output = "gb-binom", compress=TRUE, multithread=TRUE, force=TRUE)

## Fetch mitochondrial genomes from genbank
fetchSeqs("Insecta", database="genbank", out.dir="reference/insecta/genbank", quiet=FALSE, marker="mitochondria", output = "gb-binom", compress=TRUE, multithread=TRUE, force=TRUE)

```

## Download data for Arachnida

```{r retrieve arachnid seqs, eval=FALSE, include=FALSE}
#Create directories
dir.create("reference/arachnida/genbank",  recursive = TRUE)
dir.create("reference/arachnida/bold", recursive = TRUE)

## Fetch sequences from GenBank 
fetchSeqs("Arachnida", database="genbank", out.dir="reference/arachnida/genbank", downstream="Order", quiet=FALSE, output = "gb-binom", compress=TRUE, multithread=TRUE, force=TRUE)

## Fetch sequences from BOLD
fetchSeqs("Arachnida", database="bold", out.dir="reference/arachnida/bold", downstream=TRUE, quiet=FALSE, downto="Order", marker="COI-5P", output = "gb-binom",compress=TRUE, multithread=TRUE, force=TRUE)

## Fetch mitochondrial genomes from genbank
fetchSeqs("Arachnida", database="genbank", out.dir="reference/arachnida/genbank", quiet=FALSE, marker="mitochondria", output = "gb-binom", compress=TRUE, multithread=TRUE, force=TRUE)

```


# Merge sequences

```{r merge and clean}
#Merge Genbank sequences
list.files("reference/insecta/genbank/", pattern = ".fa$|.fa.gz$", full.names = TRUE, recursive = TRUE) %>% 
  purrr::map(readDNAStringSet) %>%
  purrr::map(writeXStringSet, filepath="reference/insecta/genbank/genbank_insecta_COI_COI_COX1_COXI_20200728.fa", append=TRUE, width=20000)

#Merge BOLD sequences
list.files("reference/insecta/bold/", pattern = ".fa$|.fa.gz$", full.names = TRUE, recursive = TRUE) %>% 
  purrr::map(readDNAStringSet) %>%
  purrr::map(writeXStringSet, filepath="reference/insecta/bold/bold_insecta_coi5p_20200728.fa", append=TRUE, width=20000)

#Merge Genbank sequences
list.files("reference/arachnida/genbank/", pattern = ".fa$|.fa.gz$", full.names = TRUE, recursive = TRUE) %>% 
  purrr::map(readDNAStringSet) %>%
  purrr::map(writeXStringSet, filepath="reference/arachnida/genbank/genbank_arachnida_COI_COI_COX1_COXI_20200728.fa", append=TRUE, width=20000)

#Merge BOLD sequences
list.files("reference/arachnida/bold/", pattern = ".fa$|.fa.gz$", full.names = TRUE, recursive = TRUE) %>% 
  purrr::map(readDNAStringSet) %>%
  purrr::map(writeXStringSet, filepath="reference/arachnida/bold/bold_arachnida_coi5p_20200728.fa", append=TRUE, width=20000)

#gzip merged files
mergedfiles <- c(
  "reference/insecta/genbank/genbank_insecta_COI_COI_COX1_COXI_20200728.fa",
  "reference/insecta/bold/bold_insecta_coi5p_20200728.fa",
  "reference/arachnida/genbank/genbank_arachnida_COI_COI_COX1_COXI_20200728.fa",
  "reference/arachnida/bold/bold_arachnida_coi5p_20200728.fa"
) 

#gzip all merged files
mergedfiles %>%
  purrr::map(R.utils::gzip)

#Remove seperate sequences
allfiles <- c(list.files("reference/insecta", pattern = ".fa$|.fa.gz$", full.names = TRUE, recursive = TRUE),
  list.files("reference/insecta", pattern = ".fa$|.fa.gz$", full.names = TRUE, recursive = TRUE))

file.remove(allfiles[!allfiles %in% (mergedfiles %>% paste0(., ".gz"))])

#Merge sequences
seqs <- mergedfiles %>% 
  purrr::map(readDNAStringSet) %>%
  purrr::map(writeXStringSet, filepath="reference/01_mergedseqs.fa", append=TRUE, width=20000)
R.utils::gzip("01_reference/mergedseqs.fa")

# Dereplicate duplicated accessions
seqs <- readDNAStringSet(filepath = "reference/01_mergedseqs.fa.gz")
uniqSeqs <- seqs[!duplicated(str_remove(names(seqs), "\\|.*$")),]
writeXStringSet(uniqSeqs, "reference/02_uniqSeqs.fa.gz", width=20000, compress=TRUE)

```


# Compare taxonomy mapping 

```{r compare taxonomy mapping}
#OTT Taxonomy
# Download ott taxonomy and make a database
taxreturn::download_ott_taxonomy(dest.dir="ott3.2", force=TRUE)
db <- taxreturn::get_ott_taxonomy(dir="ott3.2", filter_unplaced = FALSE)

## Map to Open tree of life taxonomy and resolve synonyms
uniqSeqs <- Biostrings::readDNAStringSet("reference/02_uniqSeqs.fa.gz")
resolved <- map_to_ott(uniqSeqs, db, resolve_synonyms=TRUE, dir="ott3.2", filter_unplaced=TRUE, remove_na = TRUE, quiet=FALSE)

#filter unplaced taxa ie "incertae_sedis,|incertae_sedis$|major_rank_conflict|unplaced|environmental|inconsistent|extinct|hidden|hybrid|not_otu|viral|barren"
resolved <- filter_unplaced(resolved, db)

#filter infraspecific taxa
resolved <- filter_infraspecifc(resolved, db)

insect::writeFASTA(resolved, file="reference/03_resolved.fa.gz", compress=TRUE)

# Filter any further sequences with problem names
resolved <- insect::readFASTA("reference/03_resolved.fa.gz")
names <- names(resolved) %>%
  str_split_fixed(";", n=2) %>%
  as_tibble() %>%
  magrittr::set_colnames(c("acc", "name"))
rem <- names %>%
  dplyr::filter(str_detect(name,                        "sp\\.|spp\\.|aff\\.|nr\\.|bv\\.|cf\\.|nom\\.|nud\\.|environment|undescribed|unverified|unclassified|uncultured|unidentif|[0-9]|[:punct:]")) %>%
  pull(acc)
name_filtered  <- subset.DNAbin(resolved, subset = !str_replace(names(resolved), "(?:.(?!;))+$", "") %in% rem)
insect::writeFASTA(name_filtered, file="reference/04_name_filtered.fa.gz", compress=TRUE)


#CHeck NCBI taxonomy
#Compare numbers of unique taxa and unique sequences that could be mapped to NCBI vs OTT taxonomy
#with remove_na=TRUE resolved wont contain any non-mapped
# While the taxid for all the rest should be NCBI or na?

uniqSeqs <- insect::readFASTA("reference/02_uniqSeqs.fa.gz")
resolved_ncbi <- resolve_synonyms_ncbi(uniqSeqs, dir="ncbi_taxdump")

# need to resolve synonyms and remove infraspecifics for a fair comaprison here for a fair comparison

mapped_ncbi <- names(resolved_ncbi) %>%
  str_split_fixed(";", n=Inf) %>%
  as.data.frame() %>% 
  tidyr::separate(V1, into=c("acc", "taxid"), sep="\\|") %>%
  mutate(taxid = taxid %>% dplyr::na_if("NA")) %>%
  dplyr::rename(name = V2) %>%
  mutate(db = "ncbi")

mapped_ott <- fasta.index("reference/03_resolved.fa.gz") %>%
tidyr::separate(desc, into=c("acc", "taxid", "name"), sep="\\||;") %>%
  dplyr::select(acc, taxid, name) %>%
  mutate(taxid = taxid %>% dplyr::na_if("NA")) %>%
  mutate(db = "ott")

joint <- bind_rows(mapped_ncbi, mapped_ott) %>%
  dplyr::filter(!is.na(taxid)) %>%
  dplyr::filter(!str_detect(name,                        "sp\\.|spp\\.|aff\\.|nr\\.|bv\\.|cf\\.|nom\\.|nud\\.|environment|undescribed|unverified|unclassified|uncultured|unidentif|[0-9]|[:punct:]")) %>%
  group_by(db) %>%
  dplyr::summarise(unique_spp = n_distinct(taxid), unique_seqs = n()) 

gg.mapping_comparison <- joint %>%
  pivot_longer(starts_with("unique"),
               names_to="type",
               values_to="value")  %>%
  ggplot(aes(x=type, y=value, fill=db, group=db)) + 
           geom_col(position="dodge") +
  base_theme +
  scale_fill_brewer(palette = "Paired") +
  labs(title="Mapped into taxonomy") +
  theme(legend.position = "bottom")

pdf(file="fig/supplementary/taxonomy_mapping_comparison.pdf", width = 8, height = 11 , paper="a4")
  plot(gg.mapping_comparison)
try(dev.off(), silent=TRUE)
```

## PHMM

### Build PHMM

```{r build PHMM}
#build PHMM from midori longest - sequences need to be same length
midori <-  Biostrings::readDNAStringSet("reference/MIDORI_LONGEST_20180221_COI.fasta")
insecta_midori <- as.DNAbin(midori[str_detect(names(midori),pattern=";Insecta;"),])
folmer <- insect::virtualPCR(insecta_midori, up = "TITCIACIAAYCAYAARGAYATTGG", down= "TAIACYTCIGGRTGICCRAARAAYCA",cores=2, rcdown = TRUE, trimprimers = FALSE)

#Filtered was then aligned in MAFFT and manually curated in geneious prime
folmer_curated <-  ape::read.dna("reference/folmer_insecta_fullength_aligned_curated.fa",format="fasta")
model <- aphid::derivePHMM(folmer_curated)
saveRDS(model, "reference/folmer_fullength_model.rds")
```


### Align to PHMM

```{r Align to phmm}
model <- readRDS("reference/folmer_fullength_model.rds")
seqs <- insect::readFASTA("reference/04_name_filtered.fa.gz")

filtered <- taxreturn::map_to_model(seqs,  model, minscore = 100,
 shave=TRUE, check_indels=TRUE,  maxNs = 0,
 multithread=8, quiet=FALSE, progress = FALSE)

#Write out results filtered results
insect::writeFASTA(filtered, file="reference/05_filtered.fa.gz",compress=TRUE)

```

## Remove stop codons

```{r stop codons}
filtered <- insect::readFASTA("reference/05_filtered.fa.gz")

# Filter for stop codons
codonfilt <- taxreturn::codon_filter(filtered)

#Write out results filtered results
insect::writeFASTA(codonfilt, file="reference/06_codon_filtered.fa.gz",compress=TRUE)
```

## Mixed clusters

```{r Mixed clusters}
codonfilt <- insect::readFASTA("reference/06_codon_filtered.fa.gz")

# Remove duplicate accesions
seqs <- insect::subset.DNAbin(codonfilt, subset = !duplicated(str_extract(names(codonfilt), "^.*\\|" )))

# flag clusters with mixed taxonomy at different cluster thresholds and taxonomic ranks
db <- taxreturn::get_ott_taxonomy(dir="ott3.2")
set.seed(666)

mixed_clusters <- purrr::map_dfr(rev(seq(0.95, 1, 0.01)), ~taxreturn::get_mixed_clusters(
    x = seqs, db=db,
    rank = c("species","genus","family"),
    threshold = .x,
    return = "consensus",
    confidence=0.6, quiet = FALSE) 
)
write.csv(mixed_clusters,"mixedclusters.csv")

mixed_clusters <- vroom::vroom("reference/mixedclusters.csv")

gg.mixed <- mixed_clusters %>%
  group_by(threshold, rank) %>%
  summarise(n=n()) %>%
  ggplot(aes(x=as.factor(threshold), y=n, fill=rank, group=rank)) + 
  geom_bar(stat="identity", position="dodge", colour="black") +
  xlab("Clustering threshold") +
  ylab("Problem Sequences") +
  ggtitle("Mixed clusters") +
  theme_classic() +
  scale_fill_brewer(name = "Taxonomic Rank", palette="Greens") 

gg.mixed

# Purge all with mixed genus at 97, with confidence > 0.6  - >0.8 is probably better - Could i justify this with a probability of lowest common anestor?
rem <- mixed_clusters %>% 
  mutate(rem = case_when(
    rank=="species" & threshold >=0.99 & confidence > 0.8 ~ TRUE,
    rank=="genus" & threshold >=0.97 & confidence > 0.8 ~ TRUE,
    rank=="family" & threshold >=0.95 & confidence > 0.8 ~ TRUE,
    TRUE  ~ FALSE
    ))%>%
  filter(rem==TRUE) %>%
  pull(Acc) %>%
  unique()

length(rem)

purged  <- subset.DNAbin(seqs, subset = !str_replace(names(seqs), "(?:.(?!;))+$", "") %in% rem)
insect::writeFASTA(purged, file="reference/07_purged.fa.gz", compress=TRUE)
```

## Remove contaminants

### Make contaminants database
```{r fetch wolbachia}
dir.create("reference/contaminants")
# Get wolbachia
fetchSeqs("wolbachia", database="genbank", out.dir="reference/contaminants", quiet=FALSE, marker="COI OR COI OR COX1 OR COXI", output = "standard", compress=FALSE, force=TRUE, multithread=FALSE)

# Get pseudogenes
fetchSeqs("Insecta", database="genbank", out.dir="reference/contaminants", downstream=FALSE, marker="COI[GENE] AND pseudo OR numt ", output = "standard", compress=TRUE, force=TRUE, multithread =FALSE)

# Exclude those without pseudo in name 
pseudo <- insect::readFASTA("reference/contaminants/Insecta_COI_AND_pseudo_numt_.fa.gz", compress=TRUE)
pseudo <- pseudo[str_detect(names(pseudo), "pseudo|numt")]
insect::writeFASTA(pseudo, "reference/contaminants/Insecta_COI_AND_pseudo_numt_filtered.fa.gz", compress=TRUE)

# Fetch human mitochondria from genbank
 searchQ <- paste("(", x, "[ORGN])", " AND (", 
                paste(c(marker), collapse = " OR "), ") AND ", 
                minlength, ":", maxlength, "[Sequence Length]", 
                sep = "")
ids <- rentrez::entrez_search(db = "nuccore", term = "NC_012920", retmax = 9999999, use_history = TRUE)$ids
dl <- rentrez::entrez_fetch(db = "nuccore", id = ids, rettype = "gb", retmax = 10000)
gb <- biofiles::gbRecord(rcd = textConnection(dl))

human_mito <- biofiles::getSequence(gb)
names(human_mito) <- paste0(biofiles::getAccession(gb), " ", biofiles::getDefinition(gb))
writeXStringSet(human_mito,"reference/contaminants/human_mito.fa")
```

### BLAST against Contaminants
```{r Contaminant BLAST}
# Blast against wolbachia
taxreturn::blast_install(dest.dir = "bin")

seqs <- insect::readFASTA("reference/07_purged.fa.gz")

matchlist_wolb <- taxreturn::blast(query=seqs, db="reference/contaminants/wolbachia_COI_COI_COX1_COXI.fa.gz", output_format = "tabular", multithread = FALSE, args="-perc_identity 80 -max_target_seqs 10 -max_hsps 10") %>%
  as.data.frame()
write_csv(matchlist_wolb, "reference/contaminants/matchlist_wolb.csv")

matchlist_pseudo <- taxreturn::blast(query=seqs, db="reference/contaminants/Insecta_COI_AND_pseudo_numt_filtered.fa", output_format = "tabular", args="-perc_identity 97 -max_target_seqs 10 -max_hsps 10", multithread = FALSE) %>%
  as.data.frame()
write_csv(matchlist_pseudo, "reference/contaminants/matchlist_pseudo.csv")

matchlist_human <- taxreturn::blast(query=seqs, db="reference/contaminants/human_mito.fa", output_format = "tabular", args="-perc_identity 97 -max_target_seqs 10 -max_hsps 10", multithread = FALSE) %>%
  as.data.frame()
write_csv(matchlist_human, "reference/contaminants/matchlist_human.csv")

#blastn -db reference/contaminants/Insecta_COI_AND_pseudo_numt_filtered.fa -query reference/blast_query.fa  -outfmt "6 qseqid sseqid pident length mismatch gapopen qstart qend sstart send evalue bitscore qcovs qcovhsp" -evalue 1e-06 -num_threads 8 -perc_identity 97 -max_target_seqs 10 -max_hsps 10 -out matchlist_pseudo.csv

#blastn -db reference/contaminants/human_mito.fa -query reference/blast_query.fa  -outfmt "6 qseqid sseqid pident length mismatch gapopen qstart qend sstart send evalue bitscore qcovs qcovhsp" -evalue 1e-06 -num_threads 8 -perc_identity 97 -max_target_seqs 10 -max_hsps 10 -out matchlist_human.csv

# flag clusters with mixed taxonomy at different cluster thresholds and taxonomic ranks
matchlist_wolb <- vroom::vroom("reference/contaminants/matchlist_wolb.csv", delim=",") %>% 
dplyr::select(-name)
matchlist_pseudo <- vroom::vroom("reference/contaminants/matchlist_pseudo.csv", delim="\t", col_names=colnames(matchlist_wolb) )
matchlist_human <- vroom::vroom("reference/contaminants/matchlist_human.csv", delim="\t", col_names=colnames(matchlist_wolb) )

#Remove sequences that match wolbachia
rem_wolb <- matchlist_wolb %>%
  dplyr::filter(qcovs >= 80, pident >= 80) %>%
  mutate(acc =str_remove(qseqid, "(?:.(?!\\|))+$") ) %>%
  pull(acc)%>%
  unique()

rem_pseudo <- matchlist_pseudo %>%
  dplyr::filter(qcovs >= 99, pident >= 99) %>%
  mutate(acc =str_remove(qseqid, "(?:.(?!\\|))+$") ) %>%
  pull(acc) %>%
  unique()

rem_human <- matchlist_human %>%
  dplyr::filter(qcovs >= 97, pident >= 97) %>%
  mutate(acc =str_remove(qseqid, "(?:.(?!\\|))+$") ) %>%
  pull(acc) %>%
  unique()

rem_bads <- readLines("reference/contaminants/bad_accessions.txt")


rem <- unique(c(rem_wolb, rem_pseudo, rem_human, rem_bads))

table(str_remove(names(seqs), "(?:.(?!\\|))+$") %in% rem)

contam_purged  <- subset.DNAbin(seqs, subset = !str_remove(names(seqs), "(?:.(?!\\|))+$") %in% rem)

length(seqs) - length(contam_purged)
insect::writeFASTA(contam_purged, file="reference/08_contam_removed.fa.gz", compress=TRUE)
```


## Filter length

```{r lengthfilt}
contam_purged <- readDNAStringSet("reference/08_contam_removed.fa.gz")

maxgaps <- 712 - 300 #minlength 300 bases

rem <- names(contam_purged)[Biostrings::letterFrequency(contam_purged, "-") > maxgaps]
lengthfilt <- contam_purged[!names(contam_purged) %in% rem]

writeXStringSet(lengthfilt, "reference/09_lengthfilt.fa.gz", compress=TRUE)
```

## Prune overrepresented groups
```{R prune}
# Prune large group sizes down to 5
set.seed(666)
lengthfilt <- insect::readFASTA("reference/09_lengthfilt.fa.gz")
pruned <- prune_groups(lengthfilt, maxGroupSize = 5, discardby="length", dedup=TRUE, quiet = FALSE)

# Reformat to full taxonomic heirarchy
db <- taxreturn::get_ott_taxonomy(dir="ott3.2")
pruned <- reformat_hierarchy(pruned, db, ranks=c("kingdom", "phylum", "class", "order", "family", "genus", "species"), quiet=FALSE)

# Drop sequences with NA taxonomy
rem <- names(pruned)[str_detect(names(pruned), ";NA;")]
subset <- pruned[!names(pruned) %in% rem]
message(paste0(length(pruned) - length(subset), " Sequences with NA's in taxonomy removed"))
pruned <- subset
insect::writeFASTA(pruned, file="reference/10_pruned.fa.gz", compress=TRUE)
```


# Reformat and Merge in inhouse sequences

```{r reformat seqs}
# read in  inhouse sequences
seqs <- readDNAStringSet(list.files("reference/inhouse/", pattern = ".fa", full.names = TRUE))

# Compare mapping to ncbi vs OTT
db <- taxreturn::get_ott_taxonomy(dir="ott3.2", filter_unplaced = FALSE)

#Get names into same format and map to ott
names(seqs) <- names(seqs) %>%
   str_split_fixed(pattern="_", n=2) %>%
  as.data.frame() %>%
  mutate(tax_name = str_replace(V2, "_", " ")) %>%
  mutate(tax_name = case_when(
    tax_name %in% (anti_join(., db, by="tax_name") %>% pull(tax_name)) ~ tax_name %>% str_remove(pattern="(\\ )(.*?)(?=$)"),
    !tax_name %in% (anti_join(., db, by="tax_name") %>% pull(tax_name)) ~ tax_name
  )) %>%
  left_join(db %>% select(-source, -id) %>% distinct(), by="tax_name") %>% 
  filter(!duplicated(V1)) %>%
  mutate(name = paste0(V1,"|", tax_id,";", V2)) %>%
  mutate(name = str_replace(name, "_", " ")) %>%
  pull(name)

#Deal with those that had NA species because only genus was in taxonomy
  
names <- reformat_hierarchy(seqs, db, quiet=FALSE, ranks=c("phylum", "class", "order", "family", "genus", "species")) %>%
  names() %>%
  str_split_fixed(pattern=";", n=Inf) %>%
  as.data.frame()%>%
  mutate(V8 = na_if(V8, "NA"))

names$V8[is.na(names$V8)] <- names(seqs)[is.na(names$V8)]%>% str_remove(pattern="^.*;")

names(seqs) <- names %>% tidyr::unite(col="names",1:8, sep = ";") %>%
  pull(names)
  
#filt using phmm
model <- readRDS("reference/folmer_fullength_model.rds")

filtered <- taxreturn::map_to_model(seqs,  model, minscore = 100,
 shave=TRUE, check_indels=TRUE,  maxNs = 0,
 multithread=1, quiet=FALSE, progress = FALSE)

# Filter for stop codons
codonfilt <- taxreturn::codon_filter(filtered)

# Write out reformatted inhouse 
insect::writeFASTA(codonfilt, file="reference/inhouse/inhouse_heirarchial.fa", compress = TRUE)

#merge
inhouse <- insect::readFASTA("reference/inhouse/inhouse_heirarchial.fa")

mergedSeqs <- c((insect::readFASTA(file="reference/10_pruned.fa.gz")), inhouse)

#Remove any non-insect or arachnid as well as duplciate accessions
mergedSeqs <- filter_by_tax(mergedSeqs, filtrank = "Class", filtvalue =c("Insecta","Arachnida"))
mergedSeqs <- mergedSeqs[!duplicated(str_remove(names(mergedSeqs), "\\|.*$"))]


insect::writeFASTA(mergedSeqs, file="reference/merged_final.fa.gz", compress = TRUE)
```

# Figure 2 - Sequence summary

```{r sequence tracker}
# Create read origins 
origin <- bind_rows(
  #Genbank Insecta
  fasta.index(list.files("reference/insecta/genbank", pattern = ".fa", full.names = TRUE)) %>%
  mutate(origin = "GenBank") %>% #genbank_insecta
  select(origin, desc),
  #BOLD Insecta
  fasta.index(list.files("reference/insecta/bold", pattern = ".fa", full.names = TRUE)) %>%
  mutate(origin = "BOLD") %>% #bold_insecta
  select(origin, desc),
  #Genbank Arachnida
  fasta.index(list.files("reference/arachnida/genbank", pattern = ".fa", full.names = TRUE)) %>%
  mutate(origin = "GenBank") %>% #genbank_arachnida
  select(origin, desc),
  #BOLD Arachnida
  fasta.index(list.files("reference/arachnida/bold", pattern = ".fa", full.names = TRUE)) %>%
  mutate(origin = "BOLD") %>% #bold_arachnida
  select(origin, desc),
) %>%
    mutate(seqid = desc %>%
    str_remove(pattern="(\\|)(.*?)(?=$)") %>%
    str_replace_all(" ", "_") ) %>%
  distinct() %>%
  mutate(Duplicated = case_when(
    duplicated(seqid) & str_detect(origin, "bold") ~ TRUE,
    TRUE ~ FALSE
    )) %>%
  filter(!Duplicated) %>%   
  filter(!duplicated(seqid)) %>%
  select(-Duplicated, -desc)

## summarise number of sequences at each stage and their origins
tracker <- bind_rows(
                  taxreturn::summarise_fasta("reference/01_mergedseqs.fa.gz",
                                             label="01_merged",
                                             origin=origin),
                  taxreturn::summarise_fasta("reference/02_uniqSeqs.fa.gz",
                                             label="02_unique",
                                             origin=origin),
                  taxreturn::summarise_fasta("reference/03_resolved.fa.gz",
                                             label="03_resolved",
                                             origin=origin),
                  taxreturn::summarise_fasta("reference/04_name_filtered.fa.gz",
                                             label="04_name_filt",
                                             origin=origin),
                  taxreturn::summarise_fasta("reference/05_filtered.fa.gz",
                                             label="05_phmm_filt",
                                             origin=origin),
                  taxreturn::summarise_fasta("reference/06_codon_filtered.fa.gz",
                                             label="06_codon_filt",
                                             origin=origin),
                  taxreturn::summarise_fasta("reference/07_purged.fa.gz",
                                             label="07_mixed_clusters",
                                             origin=origin),
                  taxreturn::summarise_fasta("reference/08_contam_removed.fa.gz",
                                             label="08_contam_removed",
                                             origin=origin), 
                  taxreturn::summarise_fasta("reference/09_lengthfilt.fa.gz",
                                             label="09_lengthfilt",
                                             origin=origin), 
                  taxreturn::summarise_fasta("reference/10_pruned.fa.gz", 
                                             label="10_pruned",
                                             origin=origin)

) %>%
  pivot_longer(cols=starts_with("n"),
               names_to = "Type",
               values_to = "value"
               )
write_csv(tracker, "reference/sequence_tracker.csv")

tracker <- read_csv("reference/sequence_tracker.csv")
tracker %>% 
  group_by(Type, label) %>%
  summarise(value = sum(value))

gg.cleaning <- tracker %>%
  filter(!origin %in% c("genbank_arachnida/genbank_insecta", "bold_arachnida/bold_insecta/genbank_arachnida/genbank_insecta")) %>%
  mutate(Type = Type %>% 
           str_replace("nseqs", "# Sequences") %>%
            str_replace("nspecies", "# Species")) %>%
  ggplot(aes(x=label, y=value, group=origin, fill=origin)) +
  geom_col(alpha=0.8) +
  facet_wrap(~Type, nrow=2, ncol=1, scales = "free_y") +
  scale_fill_brewer(palette="Paired") +
  xlab("Filter stage") +
  ylab("# Sequences") +
  scale_y_continuous(labels = scales::comma) +
  base_theme + 
  theme(legend.position="top",
        panel.grid = element_blank()) +
  labs(x = "Filter stage",
       y = NULL,
       fill = "Sequence Origin")

gg.cleaning
# find differences between lenghtfilt and pruned - why does total species reduce? is it hte way its calculated or just those that couldnt be mapped to taxonomy?

# Pre and post pruning

pruning_summary <- Biostrings::fasta.index("reference/09_lengthfilt.fa.gz") %>%
  bind_rows(Biostrings::fasta.index("reference/10_pruned.fa.gz"))%>%
  mutate(species = desc %>% str_remove("^.*;")) %>%
  mutate(stage = case_when(
    str_detect(filepath, "lengthfilt") ~ "Unpruned",
    str_detect(filepath, "pruned") ~ "Pruned"
  )) %>%
  dplyr::select(species, stage) %>%
  group_by(species, stage) %>%
  summarise(n = n())

gg.pruning <- ggplot(pruning_summary, aes(x = stage, y=n, fill=stage)) +
  geom_boxplot(colour="black", alpha = 0.5) + 
  base_theme+
  scale_y_log10() +
  scale_fill_brewer(palette = "Paired") + 
  coord_flip()+
  labs(y = "# Sequences per species", x= NULL) +
  theme(panel.grid = element_blank()) 


# Summary of unique taxa
seqs <- insect::readFASTA("reference/merged_final.fa.gz")

# Summarise unique ranks
names(seqs) %>%
  str_split_fixed(";", n=Inf) %>%
  as.data.frame() %>%
  magrittr::set_colnames(c("total", "kingdom", "phylum", "class", "order", "family", "genus", "species")) %>%
  dplyr::summarise_at(c("total", "kingdom", "phylum", "class", "order", "family", "genus", "species"), n_distinct) 


# Plot a taxonomic tree of everything, summarised at the genus level
tree <- tax2tree(seqs, summarise="Order", output="phylo", replace_bads = TRUE, append_sum = FALSE)

#Pest sums
pestlist <- read_csv("primer_evaluation/pestlist.csv") 

pest_seqs <- filter_by_tax(seqs, filtrank = "Species", filtvalue = pestlist$Species)
pest_tree <- tax2tree(pest_seqs, summarise="Order", output="phylo", replace_bads = TRUE, append_sum = FALSE)

# Plot trees
library(ggnewscale)
circ <- ggtree(tree, layout = "circular", branch.length = 'none')

circ_dat <- circ$data %>%
  left_join(names(seqs) %>%
  str_split_fixed(";", n=Inf) %>%
  as.data.frame() %>%
  magrittr::set_colnames(c("total", "kingdom", "phylum", "class", "order", "family", "genus", "species")) %>%
    dplyr::select(class, label = order)) %>%
  mutate(class = replace_na(class, "Root"))

circ <- circ %<+% circ_dat + aes(color=class) + scale_color_manual(values=c("#d8b365", "#5ab4ac", "grey80"))

plot_dat <- attr(tree, "sum") %>%
  enframe() %>%
  magrittr::set_colnames(c("name", "All")) %>%
left_join(attr(pest_tree, "sum")%>%
  enframe() %>%
  magrittr::set_colnames(c("name", "Pest"))) %>%
  #mutate(pest = replace_na(pest, 0)) %>%
  column_to_rownames("name") %>%
  as.data.frame()

p1 <- gheatmap(circ, plot_dat %>% dplyr::select(Pest), offset=0, width=.4, color="grey80",
               colnames_angle=95, colnames_offset_y = 0) +
    scale_fill_viridis_c(option="A", name="Pest Spp.") 


p2 <- p1 + new_scale_fill()
gg.phylo <- gheatmap(p2,  plot_dat %>% dplyr::select(All), offset=1.5, width=.5,
         colnames_angle=90, colnames_offset_y = 0.2, color="grey80") +
    scale_fill_viridis_c(option="D", name="All Spp.")+ 
    geom_tiplab(offset=5, align=FALSE, size=4) 


Fig2a <- gg.cleaning / gg.pruning + plot_layout(heights= c(3,1))
Fig2 <- Fig2a - gg.phylo + plot_layout(widths = c(2,3), ncol = 2)+ 
  plot_annotation(tag_levels = 'A') 

Fig2

#Save figure 2
pdf(file="fig/Fig2_database_summary.pdf", width = 11, height = 8 , paper="a4r")
  plot(Fig2)
try(dev.off(), silent=TRUE)
  
```


# Create reference set for BF1-BR1 subregion of COI

While trimming the reference database to just the subregion does not necessarily affect the results of IDTAXA, it does dramatically decrease the size and increase the speed of classification with it
```{r Create taxonomic classifier database}
mergedSeqs <- Biostrings::readDNAStringSet("reference/merged_final.fa.gz")

# cut down alignments to the BF1-BR1 subregion
amplicon <- Biostrings::subseq(mergedSeqs, start=371, end = 588)

maxgaps <- 9 # dont allow any more than 9 gaps
rem <- names(amplicon)[Biostrings::letterFrequency(amplicon, "-") > maxgaps]
amplicon <- amplicon[!names(amplicon) %in% rem]
message(paste0(length(rem), " Sequences with more than ", maxgaps, " gaps removed from alignment"))
  
insect::writeFASTA(amplicon, "reference/merged_final_bftrimmed.fa.gz", compress=TRUE)

#Add 'root' rank to match the IDTAXA
heirarchial <- amplicon
names(heirarchial) <- names(heirarchial) %>%
  str_remove(";$") %>% 
  str_split_fixed(";", n=8) %>%
  as.data.frame() %>%
  magrittr::set_colnames(c("acc","kingdom", "phylum", "class", "order", "family", "genus", "species")) %>%
  mutate(root = "Root") %>%
  tidyr::unite(name, c("acc", "root","kingdom", "phylum", "class", "order", "family", "genus", "species"), sep=";") %>%
  pull(name)

heirarchial <- del.gaps(heirarchial)
insect::writeFASTA(heirarchial, "reference/classifiers/insecta_hierarchial_bftrimmed.fa.gz", compress=TRUE)

#Format for DADA2 species classifier
rdp_species <- reformat_dada2_spp(amplicon, quiet=FALSE)
rdp_species <- del.gaps(rdp_species)
insect::writeFASTA(rdp_species, "reference/classifiers/insecta_binomial_bftrimmed.fa.gz", compress=TRUE)

# Train IDTAXA
trainingSet <- train_idtaxa(amplicon)
#Write out training set
saveRDS(trainingSet, file="reference/classifiers/idtaxa_bftrimmed.rds")

#Summarise database
taxreturn::tax2tree(heirarchial, output="treedf") %>%
  write_tsv("reference/classifiers/insecta_hierarchial_tree_summary.txt")

names(heirarchial) %>%
  str_split_fixed(";", n=Inf) %>%
  as.data.frame() %>%
  magrittr::set_colnames(c("acc","root", "kingdom", "phylum", "class", "order", "family", "genus", "species")) %>%
  tidyr::separate(col=acc, into=c("accession", "taxid")) %>%
  write_csv("reference/classifiers/insecta_hierarchial_alltaxa.csv")

names(heirarchial) %>%
  str_split_fixed(";", n=Inf) %>%
  as.data.frame() %>%
  magrittr::set_colnames(c("total","root", "kingdom", "phylum", "class", "order", "family", "genus", "species")) %>%
  dplyr::summarise_at(c("total","root", "kingdom", "phylum", "class", "order", "family", "genus", "species"), n_distinct)%>%
  write_csv("reference/classifiers/insecta_hierarchial_summary.csv")
```


# Evaluate LCA

### Creat USEARCH distance matrix

### Index jobs and submit usearch
```{bash generate job index}
#!/bin/bash
ls -d $PWD/reference/*  | grep 'merged_final' | sort -u > sequence_index.txt

sbatch --array=1-2 bash/usearch_distmat.sh
```

### Evaluate LCA
```{r evaluate LCA}
## Get LCA probs
ranks = c("kingdom", 
    "phylum", "class", "order", "family", 
    "genus", "species")

# Has to be a neater way to do this? Did recently in taxreturn

lca_probs <- fs::dir_ls(path="reference/usearch_output/", glob = "*.txt.gz") %>%
  purrr::map(function(x){
    print(x)
    vroom::vroom(x, delim="\t", col_names = c("acc1", "acc2", "dist")) %>%
    dplyr::mutate(acc1 = acc1 %>%
                    str_remove(";$"),
                  acc2 = acc2 %>%
                    str_remove(";$"),
      dist = round(dist, 2),
                  ) %>%
    group_by(dist) %>%
    group_modify(~{
      print(unique(.x$dist))
      
      df1 <- .x %>%
      tidyr::separate(acc1, into=c("Acc",ranks), sep=";") %>%
      dplyr::select(rev(ranks))

      df2 <- .x %>%
      tidyr::separate(acc2, into=c("Acc",ranks), sep=";") %>%
      dplyr::select(rev(ranks))
      
      #Get all shared ranks
      logidf <- as.data.frame(df1 == df2)
      keepvec <- unname(apply(logidf, 1, which.max))

      colnames(logidf)[keepvec] %>%
        table() %>%
        as.data.frame() %>%
        magrittr::set_colnames(c("rank", "freq")) %>%
        mutate(total=sum(freq),
               prob = freq / total , 
               dist =unique(.x$dist)) %>%
        dplyr::select(-total)
    }) 
  })%>%
bind_rows(.id="source") %>%
mutate(source = str_remove(basename(source), ".txt.gz"))

# Plot out
gg.lca <- lca %>%
  dplyr::filter(rank %in% c("species", "genus", "family", "order")) %>%
  mutate(rank = factor(rank, levels = c("species", "genus", "family", "order"))) %>%
  ggplot(aes(x=dist, y=prob, colour = rank)) +
  geom_line() +
  base_theme + 
  theme(legend.position = "bottom") +
  labs(x = "Distance", y="LCA Probability")

gg.lca

pdf(file="fig/lca_probabilities.pdf", width = 8, height = 11 , paper="a4")
  plot(gg.lca)
try(dev.off(), silent=TRUE)
 
```

# Sessioninfo
```{r sessioninfo}
sessionInfo()
```
